include::../shared/issue-footnotes.adoc[]
:serialization: ../serialization/serialization
:m3: ../metametamodel/metametamodel
:bulk: ../bulk/repo-access-api
:arch: ../reference-architecture/reference-architecture
:chunk: <<{serialization}.adoc#SerializationChunk, SerializationChunk>>

[[delta]]
= Delta Repository Access API
:toc: preamble
:toclevels: 4
:sectnumlevels: 4
:sectnums:
:!figure-caption:

The delta API *version 2024.1* is used to store and retrieve changes to nodes.
It is intended for fine-grained changes to single values.
it is *not* intended as a bulk API that updates large chunks of the model at once.

== Conventions used in this document
* ALL-CAPS key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in https://datatracker.ietf.org/doc/html/bcp14[BCP14] (https://datatracker.ietf.org/doc/html/rfc2119[RFC2119], https://datatracker.ietf.org/doc/html/rfc8174[RFC8174]) when, and only when, they appear in all capitals, as shown here.
* Footnotes refer to more discussions and rationale, but are non-normative.

== Introduction
Delta API assumes a bidirectional communication channel.
The _client_ initiates the channel with the _repository_ to open a _session_.
Both parties communicate through the established channel via _messages_.

Delta API supports these message kinds, loosely following CQRS patternfootnote:[https://en.wikipedia.org/wiki/Command_Query_Responsibility_Segregation]:

* <<queries>> initiated/requested by the client, with synchronous response by the repository.
A query requests some information from the repository without changing the repository's contents.
The repository gathers all information needed to answer the query, and sends the information back.
The repository might reply invalid queries with a failure message.

* <<commands>> initiated/requested by the client, with synchronous response by the repository.
A command requests some change to the repository.
The repository quickly confirms having _received_ the command, or rejects a _failed_ command.
However, the repository processes the command asynchronously, and eventually broadcasts the effect(s) as _event_.

* <<events>> initiated/broadcast by the repository, without response by the client.
An event describes some change that has been applied to the repository's contents.
Events correlate to their originating command(s); this command might have been sent by this client or another client.
All clients receive the same events (given the same _subscription scope_, see below).

* Session messages for bookkeeping.

A client describes the interesting part of the repository's contents by specifying its _subscription scope_.
The client receives only events on nodes within that scope.
Scope is defined by the node id of a <<{m3}.adoc#partition, partition>>; it includes all changes to the partition and all its descendants (including annotation instances).

A typical workflow for a client would be:

1. Client connects to repository and starts a session.
2. Client subscribes to some partitions with subscription queries.
The response contains a <<{serialization}.adoc#SerializationChunk, serialization chunk>> with the current contents of these partitions.
3. Client initiates its editor or processing with the chunk.
4. Client sends commands to request changes to some nodes in the subscribed partitions.
5. Client receives events with the actual changes that have been applied to the subscribed nodes.
6. Client updates its editor or processing with the event's contents.
7. Client receives events originating from other clients' commands.
8. Client updates its editor or processing with the event's contents.
9. Client ends the session.

The repository is always the ultimate arbiter of its contents.
It can decide to apply each command verbatim, with some tweaks (e.g. because of concurrent changes), or not at all (e.g. because the command would introduce containment loops).

Each repository might introduce its own strategy how to handle commands.
For example, assume client 1 sends a `deleteChild` command to delete node `X`, and then client 2 sends a `setProperty` command on node `X`. +
Repository A applies all commands in order, thus deletes node `X` and ignores the second command.
It emits one `childDeleted` event, correlated to both commands. +
Repository B keeps an internal "trash can" of all deleted nodes.
It deletes node `X` on the first command, but resurrects node `X` on the second command and changes the property as requested.
It first emits a `childDeleted` event (correlated to the first command), but later `childAdded` and `propertyChanged` events (both correlated to the second command). +
Repository C batches command processing.
It looks at both messages together, and decides it's more important to keep the new property value around.
It emits one `propertyChanged` event, correlated with both commands.

A client stays up-to-date with the repository's contents if it applies all events in order.
A client can either decide to apply its own change immediately and filter out events based on that command, or wait for the correlated event to arrive and apply the change only then.

== Description
=== Client characteristics
A client MUST identify with the repository with a _client id_.
The client id MUST be a valid <<{m3}.adoc#node-id, identifier>>.
It serves as a technical identifier.
Authentication and authorization are out of scope of this API.

=== Channel characteristics
Logically, the channel has independent parts for each kind of message;
in practice, we might transmit some or all of them through a shared channel.

This protocol is agnostic of its underlying technical implementation.
We can use any (e.g. stateless, stateful) protocol, as long as it fulfills request/response characteristics for client-initiated query, command, and session messages, and repository-initiated broadcast characteristics for event messages.

[[session, session]]
=== Session characteristics
One client may have more than one open session.
The client has the responsibility to guarantee uniqueness of query / command / session message ids.

=== Message characteristics
Each message is atomic; it cannot be split.

We assume the underlying protocol handles quality of service concerns (e.g. guaranteed one-time complete delivery of messages), they are out of scope of this API.

Each message has some id unique to the session:

* Queries have a _query id_.
* Commands have a _command id_.
* Events have _origin commands_.

== Open questions
#TODO#

* For new nodes, do we only send their id + classifier, or a complete node?

* Which of the events can potentially create invalid (recursively contained) trees?

* Which kind of errors do we accept?
How does this interact with concurrent edits?
Example: Does <<cmd-deleteChild>> fail if the `removedChild` does not exist?

* in removal cases (e.g. <<cmd-deleteChild>>), do we want to send only the removed id or the whole node?

* Do we need "swapNodes" event?

* Wording for commands/events: Shall we use "deleteXxx" everywhere? Or "removeXxx"? Or "deleteXxx" for deleting nodes, and "removeXxx" for removing properties / references?

* Decide on errors marked with #?# (invalid optional parameter values){fn-org312}

* How to report a command has completely been discarded, without any resulting event?{fn-org314}

== Scenarios
include::scenarios/virginRepo.adoc[]

include::scenarios/reconnectKnownPartition.adoc[]

include::scenarios/changeKnownNodeRemoteUpdate.adoc[]

include::scenarios/changeKnownNodeLocalUpdate.adoc[]

include::scenarios/changeUnknownNodeFailedCommand.adoc[]

include::scenarios/changeUnknownNodeFailedEvent.adoc[]

include::scenarios/changeSameValueRemoteUpdate.adoc[]

include::scenarios/repositoryBug.adoc[]

include::scenarios/concurrentChangeLocalUpdate.adoc[]

include::scenarios/concurrentChangeRemoteUpdate.adoc[]

== Messages
=== Parameter types
[horizontal]
[[nodeType]]Node:: Whole node encoded as <<{serialization}.adoc#node, node>>.

[[targetNodeType]]TargetNode:: Target's node as <<{m3}.adoc#identifiers, id>>.

[[metaPointerType]]MetaPointer:: MetaPointer-tuple to describe an M2 element (classifier, feature, etc.).
Encoded as <<{serialization}.adoc#meta-pointer, meta-pointer>>.

[[propertyValueType]]PropertyValue:: Property value encoded as <<{serialization}.adoc#property-values, property value>>.

[[resolveInfoType]]ResolveInfo:: ResolveInfo of a reference as string.
Can be `null`.

[[indexType]]Index:: Position inside a multiple link or annotations as integer >= 0.
Cannot be `null`.
Use value `0` for <<{m3}.adoc#multiplicity, single links>>.

[[commandType]]Command:: Any <<commands, command>>.

[[commandIdType]]CommandId:: Id of a command.{fn-org305}
Same format as <<{m3}.adoc#identifiers, node ids>>; must be unique per <<session>>.

[[queryIdType]]QueryId:: Id of a query.
Same format as <<{m3}.adoc#identifiers, node ids>>; must be unique per <<session>>.

[[chunkType]]SerializationChunk:: <<{serialization}.adoc, Chunk of nodes>>.

[[eventType]]Event:: Any <<events, event>>.

[[commandSourceType]]CommandSource:: _[clientId, commandId]_ tuple{fn-org306} this event is based on.
This allows a client to know when its command has been processed (either successful or not).

[[freeIdType]]FreeId:: Free <<{m3}.adoc#identifiers, node id>>.

==== How to calculate a CommandSource
`commandSource = base64urlEncode(sha256(concat(clientId, commandId)))`{fn-org306}

1. Concatenate the `clientId` and `commandId`
2. Calculate sha256 hash of that concatenated string
3. Encode the hash with base64url scheme.

Rationale: The originating client for this command does know both the client id and command id.
The same applies for the repository, but NOT other clients.
So the originating client and the repository can calculate the `commandSource`, but not any other client.
Thus, the command -- event correlation is possible for the originating client without revealing any origin information to other clients.

==== How to address references
We refer to references by the tuple of _[parent, reference, index]_.
Rationale: Both reference `target` and `resolveInfo` can be `null`, so they aren't suitable for identifying the reference.
However, `target` and `resolveInfo` MUST NOT both be `null`.


[[queries]]
=== Queries

[[cmd-subscription]]
==== Subscription

[[qry-subscribePartitions]]
===== Subscribe to partition changes
This client wants to receive events on newly created (`creation` is true) or deleted (`deletion` is true) partitions, and automatically subscribe (`partitions` is true) to newly created partitions.

[horizontal]
.Request parameters
creation:: `boolean` Whether this client wants to receive events on newly created partitions (`true`), or not (`false`).

deletion:: `boolean` Whether this client wants to receive events on deleted partitions (`true`), or not (`false`).

partitions:: `boolean` Whether this client wants to automatically subscribe to newly created partitions (`true`), or not (`false`).

queryId:: <<queryIdType>> Id of this query.

[horizontal]
.Response parameters
queryId:: <<queryIdType>>  Id of this query.

.Errors
_none_

.Technical name
`subscribePartitions`

[[qry-subscribePartition]]
===== Subscribe to partition
This client wants to receive events on any changes to `partition` or any of its descendants.

[horizontal]
.Request parameters
partition:: <<targetNodeType>> Node id of the partition this client wants to receive events of.

queryId:: <<queryIdType>> Id of this query.

[horizontal]
.Response parameters
contents:: <<chunkType>> Complete contents of `partition`, i.e. the node with id `partition` and all of its descendants (including annotation instances).

queryId:: <<queryIdType>> Id of this query.

.Errors
* already subscribed to `partition`

.Technical name
`subscribePartition`

[[cmd-unsubscribePartition]]
===== Unsubscribe from partition
This client does not want to receive events on any changes to `partition` or any of its descendants anymore.

[horizontal]
.Request parameters
partition:: <<targetNodeType>> Node id of the partition this client wants to stop receiving events of.
queryId:: <<queryIdType>> Id of this query.

[horizontal]
.Response parameters
queryId:: <<queryIdType>> Id of this query.

.Errors
* not subscribed to `partition`

.Technical name
`unsubscribePartition`

[[cmd-misc]]
==== Miscellaneous

[[cmd-getAvailableIds]]
===== Get available ids
Request `count` number of unused <<{m3}.adoc#identifiers, valid ids>>.

Same functionality as <<{bulk}.adoc#ids, bulk API ids command>>.

We don't assume leases, i.e. ids handed out to one client are "owned" by that client forever.


[horizontal]
.Request parameters
count:: `integer` Number of ids requested.
queryId:: <<queryIdType>> Id of this query.

[horizontal]
.Response parameters
ids:: <<freeIdType>>[] List of ids guaranteed to be free.
The repository MUST return between one (inclusive) and `count` (inclusive) ids.
It MAY return less than `count` ids.

queryId:: <<queryIdType>> Id of this query.

.Errors
_none_

.Technical name
`getAvailableIds`


=== Command -- event pairs overview
include::commandEventOverview/legend.adoc[]

==== Partitions
[cols="30a,35a,35a"]
|===
|Command / Event / Description |Before |After

|
<<cmd-addPartition>>

<<evnt-partitionAdded>>

Add `newPartition` node as new partition.
include::commandEventOverview/addPartition.adoc[]

|
<<cmd-deletePartition>>

<<evnt-partitionDeleted>>

Delete partition `deletedPartition`.
include::commandEventOverview/deletePartition.adoc[]
|===

==== Nodes
[cols="30a,35a,35a"]
|===
|Command / Event / Description |Before |After

|
<<cmd-changeClassifier>>

<<evnt-conceptChanged>>

Change concept of `node` from `oldConcept` to `newConcept`.
include::commandEventOverview/changeConcept.adoc[]
|===

==== Properties
[cols="30a,35a,35a"]
|===
|Command / Event / Description |Before |After

|
<<cmd-addProperty>>

<<evnt-propertyAdded>>

Add `newValue` as value of property `property` to `node`.
include::commandEventOverview/addProperty.adoc[]

|
<<cmd-deleteProperty>>

<<evnt-propertyDeleted>>

Delete existing `property` with `oldValue` from `node`.
include::commandEventOverview/deleteProperty.adoc[]

|
<<cmd-changeProperty>>

<<evnt-propertyChanged>>

Change existing `property` of `node` from `oldValue` to `newValue`.
include::commandEventOverview/changeProperty.adoc[]
|===

==== Children
[cols="30a,35a,35a"]
|===
|Command / Event / Description |Before |After

|
<<cmd-addChild>>

<<evnt-childAdded>>

Add new node `newChild` to `parent` in `containment` at `index`.
include::commandEventOverview/addChild.adoc[]

|
<<cmd-deleteChild>>

<<evnt-childDeleted>>

Delete existing node `deletedChild` from ``parent``'s `containment` at `index`.
include::commandEventOverview/deleteChild.adoc[]

|
<<cmd-replaceChild>>

<<evnt-childReplaced>>

Replace existing node `replacedChild` inside ``parent``'s `containment` at `index` with new node `newChild`.
Delete `replacedChild`.
include::commandEventOverview/replaceChild.adoc[]

|
<<cmd-moveChildFromOtherContainment>>

<<evnt-childMovedFromOtherContainment>>

Move existing node `movedChild` (currently inside ``oldParent``'s `oldContainment` at `oldIndex`)
inside ``newParent``'s `newContainment` at `newIndex`.
include::commandEventOverview/moveChildFromOtherContainment.adoc[]
|

<<cmd-moveChildFromOtherContainmentInSameParent>>

<<evnt-childMovedFromOtherContainmentInSameParent>>

Move existing node `movedChild` (currently inside ``parent``'s `oldContainment` at `oldIndex`)
inside ``parent``'s `newContainment` at `newIndex`.
include::commandEventOverview/moveChildFromOtherContainmentInSameParent.adoc[]

|
<<cmd-moveChildInSameContainment>>

<<evnt-childMovedInSameContainment>>

Move existing node `movedChild` (currently inside ``parent``'s `containment` at `oldIndex`)
inside ``parent``'s `containment` at `newIndex`.
include::commandEventOverview/moveChildInSameContainment.adoc[]

|===

==== Annotations
[cols="30a,35a,35a"]
|===
|Command / Event / Description |Before |After

|
<<cmd-addAnnotation>>

<<evnt-annotationAdded>>

Add new node `newAnnotation` to ``parent``'s annotations at `index`.
include::commandEventOverview/addAnnotation.adoc[]

|
<<cmd-deleteAnnotation>>

<<evnt-annotationDeleted>>

Delete existing node `deletedAnnotation` from ``parent``'s annotations at `index`.
include::commandEventOverview/deleteAnnotation.adoc[]

|
<<cmd-replaceAnnotation>>

<<evnt-annotationReplaced>>

Replace existing node `replacedAnnotation` inside ``parent``'s annotations at `index` with new node `newAnnotation`.
Delete `replacedAnnotation`.
include::commandEventOverview/replaceAnnotation.adoc[]

|
<<cmd-moveAnnotationFromOtherParent>>

<<evnt-annotationMovedFromOtherParent>>

Move existing node `movedAnnotation` (currently inside ``oldParent``'s annotations at `oldIndex`)
inside ``newParent``'s annotations at `newIndex`.
include::commandEventOverview/moveAnnotationFromOtherParent.adoc[]

|
<<cmd-moveAnnotationInSameParent>>

<<evnt-annotationMovedInSameParent>>

Move existing node `movedAnnotation` (currently inside ``parent``'s annotations at `oldIndex`)
inside ``parent``'s annotations at `newIndex`.
include::commandEventOverview/moveAnnotationInSameParent.adoc[]

|===

==== References
[cols="30a,35a,35a"]
|===
|Command / Event / Description |Before |After

|
<<cmd-addReference>>

<<evnt-referenceAdded>>

Add `newTarget` / `newResolveInfo` to ``parent``'s `reference` at `index`.
include::commandEventOverview/addReference.adoc[]

|
<<cmd-deleteReference>>

<<evnt-referenceDeleted>>

Delete existing `deletedTarget`/`deletedResolveInfo` from ``parent``'s `reference` at `index`.
include::commandEventOverview/deleteReference.adoc[]

|
<<cmd-changeReference>>

<<evnt-referenceChanged>>

Replace existing `replacedTarget`/`replacedResolveInfo`  inside ``parent``'s `reference` at `index` with `newTarget`/`newResolveInfo`.
include::commandEventOverview/changeReference.adoc[]

|
<<cmd-moveEntryFromOtherReference>>

<<evnt-entryMovedFromOtherReference>>

Move existing `target`/`resolveInfo` (currently inside ``oldParent``'s `oldReference` at `oldIndex`)
to ``newParent``'s `newReference` at `newIndex`.
include::commandEventOverview/moveEntryFromOtherReference.adoc[]

|
<<cmd-moveEntryFromOtherReferenceInSameParent>>

<<evnt-entryMovedFromOtherReferenceInSameParent>>

Move existing `target`/`resolveInfo` (currently inside ``parent``'s `oldReference` at `oldIndex`)
to ``parent``'s `newReference` at `newIndex`.
include::commandEventOverview/moveEntryFromOtherReferenceInSameParent.adoc[]

|
<<cmd-moveEntryInSameReference>>

<<evnt-entryMovedInSameReference>>

Move existing `target`/`resolveInfo` (currently inside ``parent``'s `reference` at `oldIndex`)
inside ``parent``'s `reference` at `newIndex`.
include::commandEventOverview/moveEntryInSameReference.adoc[]

|
<<cmd-addReferenceResolveInfo>>

<<evnt-referenceResolveInfoAdded>>

Add `newResolveInfo` as ResolveInfo to existing entry inside ``parent``'s `reference` at `index` with `target`.
include::commandEventOverview/addReferenceResolveInfo.adoc[]

|
<<cmd-deleteReferenceResolveInfo>>

<<evnt-referenceResolveInfoDeleted>>

Delete existing `deletedResolveInfo` as ResolveInfo from existing entry inside ``parent``'s `reference` at `index` with `target`.
include::commandEventOverview/deleteReferenceResolveInfo.adoc[]

|
<<cmd-changeReferenceResolveInfo>>

<<evnt-referenceResolveInfoChanged>>

Change ResolveInfo of existing entry inside ``parent``'s `reference` at `index` from `oldResolveInfo` to `newResolveInfo`.
include::commandEventOverview/changeReferenceResolveInfo.adoc[]

|
<<cmd-addReferenceTarget>>

<<evnt-referenceTargetAdded>>

Add `newTarget` as target to existing entry inside ``parent``'s `reference` at `index` with `resolveInfo`.
include::commandEventOverview/addReferenceTarget.adoc[]

|
<<cmd-deleteReferenceTarget>>

<<evnt-referenceTargetDeleted>>

Delete existing `deletedTarget` as target from existing entry inside ``parent``'s `reference` at `index` with `resolveInfo`.
include::commandEventOverview/deleteReferenceTarget.adoc[]

|
<<cmd-changeReferenceTarget>>

<<evnt-referenceTargetChanged>>

Change target of existing entry inside ``parent``'s `reference` at `index` with `resolveInfo` from `oldTarget` to `newTarget`.
include::commandEventOverview/changeReferenceTarget.adoc[]

|===


[[commands]]
=== Commands

==== Lifecycle
[plantuml, commandsLifecycle, svg]
----
hide empty description

[*] -> Created: <i>client</i>\ncreates
Created -> Sent: <i>client</i>\nsends

Sent --> Failed: <i>repository</i>\ninvalid command
Failed -> [*]: <i>client</i>\ndiscards

Sent -> Received: <i>repository</i>\nreceives
Received -> Processed: <i>repository</i> emits event,\n<i>client</i> receives event
Processed --> [*]: <i>client</i>\ndiscards
----

[[cmd-partitions]]
==== Partitions

[[cmd-addPartition]]
===== Add partition
Add `newPartition` node as new partition.

[horizontal]
.Parameters
newPartition:: <<nodeType>> root node to form a new partition.
It MUST contain _id_ and _classifier_.
It MAY contain _properties_.
It MUST NOT contain _containments_, _references_, _annotations_, or _parent_ (as this is a partition, thus cannot have a parent).

commandId:: <<commandIdType>> Id of this command.

.Errors
* node with `newPartition` id already exists

.Technical name
`addPartition`

.Related event
<<evnt-partitionAdded>>

[[cmd-deletePartition]]
===== Delete partition
Delete partition `deletedPartition`, and all its descendants (including annotation instances).

[horizontal]
.Parameters
deletedPartition:: <<nodeType>> or <<targetNodeType>> #TODO#
commandId:: <<commandIdType>> Id of this command.

.Errors
* `deletedPartition` does not exist

.Technical name
`deletePartition`

.Related event
<<evnt-partitionDeleted>>

[[cmd-nodes]]
==== Nodes

[[cmd-changeClassifier]]
===== Change classifier
Change classifier of `node` from `oldClassifier` to `newClassifier`.

[horizontal]
.Parameters
node:: <<targetNodeType>>
newClassifier:: <<metaPointerType>>
oldClassifier:: <<metaPointerType>>
commandId:: <<commandIdType>> Id of this command.

.Errors
* `node` does not exist
* ##?## `node` currently does not have concept `oldConcept`

.Technical name
`changeConcept`

.Related event
<<evnt-conceptChanged>>

[[cmd-properties]]
==== Properties

[[cmd-addProperty]]
===== Add property
Add `newValue` as value of property `property` to `node`.

[horizontal]
.Parameters
node:: <<targetNodeType>>
property:: <<metaPointerType>>
newValue:: <<propertyValueType>>
commandId:: <<commandIdType>>

.Errors
* `node` does not exist
* ##?## `property` already set in `node`

.Technical name
`addProperty`

.Related event
<<evnt-propertyAdded>>

[[cmd-deleteProperty]]
===== Delete property
Delete existing `property` with `oldValue` from `node`.

[horizontal]
.Parameters
node:: <<targetNodeType>>
property:: <<metaPointerType>>
oldValue:: <<propertyValueType>>
commandId:: <<commandIdType>>

.Errors
* `node` does not exist
* ##?## `property` is not set in `node`
* ##?## `property` currently does not have `oldValue`

.Technical name
`deleteProperty`

.Related event
<<evnt-propertyDeleted>>

[[cmd-changeProperty]]
===== Change property
Change existing `property` of `node` from `oldValue` to `newValue`.

[horizontal]
.Parameters
node:: <<targetNodeType>>
property:: <<metaPointerType>>
newValue:: <<propertyValueType>>
oldValue:: <<propertyValueType>>
commandId:: <<commandIdType>>

.Errors
* `node` does not exist
* ##?## `property` is not set in `node`
* ##?## `property` currently does not have `oldValue`


.Technical name
`changeProperty`

.Related event
<<evnt-propertyChanged>>

[[cmd-children]]
==== Children

[[cmd-addChild]]
===== Add child
Add new node `newChild` to `parent` in `containment` at `index`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
newChild:: <<nodeType>>
containment:: <<metaPointerType>>
index:: <<indexType>>
commandId:: <<commandIdType>>

.Events
* `parent` does not exist
* `newChild` id already exists
* `index` is beyond the number of `containment` entries in `parent`

.Technical name
`addChild`

.Related event
<<evnt-childAdded>>

[[cmd-deleteChild]]
===== Delete child
Delete existing node `deletedChild` from ``parent``'s `containment` at `index`.

[horizontal]
.Parameters
deletedChild:: <<nodeType>> or <<targetNodeType>> #TODO#
parent:: <<targetNodeType>>
containment:: <<metaPointerType>>
index:: <<indexType>>
commandId:: <<commandIdType>>

.Errors
* `deletedChild` does not exist
* `parent` does not exist
* `deletedChild` is not a child of `parent` in `containment`
* ##?## `index` is beyond (the number of `containment` entries in `parent`) - 1
* ##?## `deletedChild` is not the node at ``parent``'s `containment` at `index`.

.Technical name
`deleteChild`

.Related event
<<evnt-childDeleted>>

[[cmd-replaceChild]]
===== Replace child
Replace existing node `replacedChild` inside ``parent``'s `containment` at `index` with new node `newChild`.
Delete `replacedChild`.

[horizontal]
.Parameters
newChild:: <<nodeType>>
replacedChild:: <<nodeType>> or <<targetNodeType>> #TODO#
parent:: <<targetNodeType>>
containment:: <<metaPointerType>>
index:: <<indexType>>
commandId:: <<commandIdType>>

.Errors
* `newChild` id already exists
* `replacedChild` does not exist
* `parent` does not exist
* `replacedChild` is not a child of `parent` in `containment`
* ##?## `index` is beyond (the number of `containment` entries in `parent`) - 1
* ##?## `replacedChild` is not the node at ``parent``'s `containment` at `index`.

.Technical name
`replaceChild`

.Related event
<<evnt-childReplaced>>

[[cmd-moveChildFromOtherContainment]]
===== Move child from other containment
Move existing node `movedChild` (currently inside ``oldParent``'s `oldContainment` at `oldIndex`)
inside ``newParent``'s `newContainment` at `newIndex`.

[horizontal]
.Parameters
newParent:: <<targetNodeType>>
newContainment:: <<metaPointerType>>
newIndex:: <<indexType>>
movedChild:: <<targetNodeType>>
oldParent:: <<targetNodeType>>
oldContainment:: <<metaPointerType>>
oldIndex:: <<indexType>>
commandId:: <<commandIdType>>

.Errors
* `newParent` does not exist
* `newIndex` is beyond the number of `newContainment` entries in `newParent`
* `movedChild` does not exist
* ##?## `oldParent` does not exist
* ##?## `movedChild` is not a child of `oldParent` in `oldContainment`
* ##?## `oldIndex` is beyond (the number of `oldContainment` entries in `oldParent`) - 1
* ##?## `movedChild` is not the node at ``oldParent``'s `oldContainment` at `oldIndex`.

.Technical name
`moveChildFromOtherContainment`

.Related event
<<evnt-childMovedFromOtherContainment>>

[[cmd-moveChildFromOtherContainmentInSameParent]]
===== Move child from other containment in same parent
Move existing node `movedChild` (currently inside ``parent``'s `oldContainment` at `oldIndex`)
inside ``parent``'s `newContainment` at `newIndex`.

[horizontal]
.Parameters
newContainment:: <<metaPointerType>>
newIndex:: <<indexType>>
movedChild:: <<targetNodeType>>
parent:: <<targetNodeType>>
oldContainment:: <<metaPointerType>>
oldIndex:: <<indexType>>
commandId:: <<commandIdType>>

.Errors
* `newIndex` is beyond the number of `newContainment` entries in `parent`
* `movedChild` does not exist
* `parent` does not exist
* `movedChild` is not a child of `parent` in `oldContainment`
* ##?## `oldIndex` is beyond (the number of `oldContainment` entries in `parent`) - 1
* ##?## `movedChild` is not the node at ``parent``'s `oldContainment` at `oldIndex`.

.Technical name
`moveChildFromOtherContainmentInSameParent`

.Related event
<<evnt-childMovedFromOtherContainmentInSameParent>>

[[cmd-moveChildInSameContainment]]
===== Move child in same containment
Move existing node `movedChild` (currently inside ``parent``'s `containment` at `oldIndex`)
inside ``parent``'s `containment` at `newIndex`.

[horizontal]
.Parameters
newIndex:: <<indexType>>
movedChild:: <<targetNodeType>>
parent:: <<targetNodeType>>
containment:: <<metaPointerType>>
oldIndex:: <<indexType>>
commandId:: <<commandIdType>>

.Errors
* `newIndex` is beyond (the number of `containment` entries in `parent`) - 1
* `movedChild` does not exist
* `parent` does not exist
* ##?## `movedChild` is not a child of `parent` in `containment`
* ##?## `oldIndex` is beyond (the number of `containment` entries in `parent`) - 1
* `newIndex` is same as `oldIndex`
* ##?## `movedChild` is not the node at ``parent``'s `containment` at `oldIndex`.

.Technical name
`moveChildInSameContainment`

.Related event
<<evnt-childMovedInSameContainment>>

[[cmd-annotations]]
==== Annotations

[[cmd-addAnnotation]]
===== Add annotation
Add new node `newAnnotation` to ``parent``'s annotations at `index`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
newAnnotation:: <<nodeType>>
index:: <<indexType>>
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `newAnnotation` id already exists
* `index` is beyond the number of annotations of `parent`

.Technical name
`addAnnotation`

.Related event
<<evnt-annotationAdded>>

[[cmd-deleteAnnotation]]
===== Delete annotation
Delete existing node `deletedAnnotation` from ``parent``'s annotations at `index`.

[horizontal]
.Parameters
deletedAnnotation:: <<nodeType>> or <<targetNodeType>> #TODO#
parent:: <<targetNodeType>>
index:: <<indexType>>
commandId:: <<commandIdType>>

.Errors
* `deletedAnnotation` does not exist
* `parent` does not exist
* `deletedAnnotation` is not an annotation of `parent`
* `index` is beyond (the number of annotations of `parent`) - 1
* ##?## `deletedAnnotation` is not the node at ``parent``'s annotations at `index`.

.Technical name
`deleteAnnotation`

.Related event
<<evnt-annotationDeleted>>

[[cmd-replaceAnnotation]]
===== Replace annotation
Replace existing node `replacedAnnotation` inside ``parent``'s annotations at `index` with new node `newAnnotation`.
Delete `replacedAnnotation`.

[horizontal]
.Parameters
newAnnotation:: <<nodeType>>
replacedAnnotation:: <<nodeType>> or <<targetNodeType>> #TODO#
parent:: <<targetNodeType>>
index:: <<indexType>>
commandId:: <<commandIdType>>

.Errors
* `newAnnotation` id already exists
* `replacedAnnotation` does not exist
* `parent` does not exist
* `replacedAnnotation` is not an annotation of `parent`
* `index` is beyond (the number of annotations of `parent`) - 1
* ##?## `replacedAnnotation` is not the node at ``parent``'s annotations at `index`.

.Technical name
`replaceAnnotation`

.Related event
<<evnt-annotationReplaced>>

[[cmd-moveAnnotationFromOtherParent]]
===== Move annotation from other parent
Move existing node `movedAnnotation` (currently inside ``oldParent``'s annotations at `oldIndex`)
inside ``newParent``'s annotations at `newIndex`.

[horizontal]
.Parameters
newParent:: <<targetNodeType>>
newIndex:: <<indexType>>
movedAnnotation:: <<targetNodeType>>
oldParent:: <<targetNodeType>>
oldIndex:: <<indexType>>
commandId:: <<commandIdType>>

.Errors
* `newParent` does not exist
* `index` is beyond the number of annotations of `newParent`
* `movedAnnotation` does not exist
* `oldParent` does not exist
* `movedAnnotation` is not an annotation of `oldParent`
* `oldIndex` is beyond (the number of annotations of `oldParent`) - 1
* ##?## `movedAnnotation` is not the node at ``oldParent``'s annotations at `oldIndex`.

.Technical name
`moveAnnotationFromOtherParent`

.Related event
<<evnt-annotationMovedFromOtherParent>>


[[cmd-moveAnnotationInSameParent]]
===== Move annotation in same parent
Move existing node `movedAnnotation` (currently inside ``parent``'s annotations at `oldIndex`)
inside ``parent``'s annotations at `newIndex`.

[horizontal]
.Parameters
newIndex:: <<indexType>>
movedAnnotation:: <<targetNodeType>>
parent:: <<targetNodeType>>
oldIndex:: <<targetNodeType>>
commandId:: <<commandIdType>>

.Errors
* `newIndex` is beyond (the number of annotations of `parent`) - 1
* `movedAnnotation` does not exist
* `parent` does not exist
* `movedAnnotation` is not an annotation of `parent`
* `oldIndex` is beyond (the number of annotations of `parent`) - 1
* ##?## `movedAnnotation` is not the node at ``parent``'s annotations at `oldIndex`.

.Technical name
`moveAnnotationInSameParent`

.Related event
<<evnt-annotationMovedInSameParent>>

[[cmd-references]]
==== References

[[cmd-addReference]]
===== Add reference
Add `newTarget` / `newResolveInfo` to ``parent``'s `reference` at `index`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newTarget:: <<targetNodeType>>?
newResolveInfo:: <<resolveInfoType>>?
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond the number of `reference` entries of `parent`
* `newTarget` is `null` and `newResolveInfo` is `null`

.Technical name
`addReference`

.Related event
<<evnt-referenceAdded>>

[[cmd-deleteReference]]
===== Delete reference
Delete existing `deletedTarget`/`deletedResolveInfo` from ``parent``'s `reference` at `index`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
deletedTarget:: <<targetNodeType>>?
deletedResolveInfo:: <<resolveInfoType>>?
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `deletedTarget` is `null` and `deletedResolveInfo` is `null`
* ##?## `deletedTarget` is not the target at ``parent``'s `reference` at `index`.
* ##?## `deletedResolveInfo` is not the resolveInfo at ``parent``'s `reference` at `index`.

.Technical name
`deleteReference`

.Related event
<<evnt-referenceDeleted>>

[[cmd-changeReference]]
===== Change reference
Replace existing `replacedTarget`/`replacedResolveInfo`  inside ``parent``'s `reference` at `index` with `newTarget`/`newResolveInfo`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newTarget:: <<targetNodeType>>?
newResolveInfo:: <<targetNodeType>>?
replacedTarget:: <<targetNodeType>>?
replacedResolveInfo:: <<resolveInfoType>>?
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `newTarget` is `null` and `newResolveInfo` is `null`
* `replacedTarget` is `null` and `replacedResolveInfo` is `null`
* ##?## `replacedTarget` is not the target at ``parent``'s `reference` at `index`.
* ##?## `replacedResolveInfo` is not the resolveInfo at ``parent``'s `reference` at `index`.

.Technical name
`changeReference`

.Related event
<<evnt-referenceChanged>>

[[cmd-moveEntryFromOtherReference]]
===== Move entry from other reference
Move existing `target`/`resolveInfo` (currently inside ``oldParent``'s `oldReference` at `oldIndex`)
to ``newParent``'s `newReference` at `newIndex`.

[horizontal]
.Parameters
newParent:: <<targetNodeType>>
newReference:: <<metaPointerType>>
newIndex:: <<indexType>>
oldParent:: <<targetNodeType>>
oldReference:: <<metaPointerType>>
oldIndex:: <<indexType>>
target:: <<targetNodeType>>?
resolveInfo:: <<resolveInfoType>>?
commandId:: <<commandIdType>>

.Errors
* `newParent` does not exist
* `newIndex` is beyond (the number of `newReference` entries of `newParent`)
* `oldIndex` is beyond (the number of `oldReference` entries of `oldParent`) - 1
* `target` is `null` and `resolveInfo` is `null`
* ##?## `target` is not the target at ``oldParent``'s `oldReference` at `oldIndex`.
* ##?## `resolveInfo` is not the resolveInfo at ``oldParent``'s `oldReference` at `oldIndex`.

.Technical name
`moveEntryFromOtherReference`

.Related event
<<evnt-entryMovedFromOtherReference>>

[[cmd-moveEntryFromOtherReferenceInSameParent]]
===== Move entry from other reference in same parent
Move existing `target`/`resolveInfo` (currently inside ``parent``'s `oldReference` at `oldIndex`)
to ``parent``'s `newReference` at `newIndex`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
newReference:: <<metaPointerType>>
newIndex:: <<indexType>>
oldReference:: <<metaPointerType>>
oldIndex:: <<indexType>>
target:: <<targetNodeType>>?
resolveInfo:: <<resolveInfoType>>?
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `newIndex` is beyond (the number of `newReference` entries of `parent`)
* `oldIndex` is beyond (the number of `oldReference` entries of `parent`) - 1
* `target` is `null` and `resolveInfo` is `null`
* ##?## `target` is not the target at ``parent``'s `oldReference` at `oldIndex`.
* ##?## `resolveInfo` is not the resolveInfo at ``parent``'s `oldReference` at `oldIndex`.

.Technical name
`moveEntryFromOtherReferenceInSameParent`

.Related event
<<evnt-entryMovedFromOtherReferenceInSameParent>>

[[cmd-moveEntryInSameReference]]
===== Move entry in same reference
Move existing `target`/`resolveInfo` (currently inside ``parent``'s `reference` at `oldIndex`)
inside ``parent``'s `reference` at `newIndex`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
oldIndex:: <<indexType>>
newIndex:: <<indexType>>
target:: <<targetNodeType>>?
resolveInfo:: <<resolveInfoType>>?
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `newIndex` is beyond (the number of `reference` entries of `parent`) - 1
* `oldIndex` is beyond (the number of `reference` entries of `parent`) - 1
* `target` is `null` and `resolveInfo` is `null`
* ##?## `target` is not the target at ``parent``'s `reference` at `oldIndex`.
* ##?## `resolveInfo` is not the resolveInfo at ``parent``'s `reference` at `oldIndex`.

.Technical name
`moveEntryInSameReference`

.Related event
<<evnt-entryMovedInSameReference>>

[[cmd-addReferenceResolveInfo]]
===== Add reference ResolveInfo
Add `newResolveInfo` as ResolveInfo to existing entry inside ``parent``'s `reference` at `index` with `target`.

****
`target` MUST NOT be `null` as we can only add ResolveInfo if ResolveInfo is `null`, and at least one of target and ResolveInfo MUST always be non-`null`.
****

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newResolveInfo:: <<resolveInfoType>>
target:: <<targetNodeType>>
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `newResolveInfo` is `null`
* ##?## resolveInfo already set in ``parent``'s `reference` at `index`.

.Technical name
`addReferenceResolveInfo`

.Related event
<<evnt-referenceResolveInfoAdded>>

[[cmd-deleteReferenceResolveInfo]]
===== Delete reference ResolveInfo
Delete existing `deletedResolveInfo` as ResolveInfo from existing entry inside ``parent``'s `reference` at `index` with `target`.

****
`target` MUST NOT be `null` as we're about to remove ResolveInfo, and at least one of target and ResolveInfo MUST always be non-`null`.
****

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
target:: <<targetNodeType>>
deletedResolveInfo:: <<resolveInfoType>>
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `deletedResolveInfo` is `null`
* `target` is `null`
* ##?## resolveInfo is not set in ``parent``'s `reference` at `index`.
* ##?## resolveInfo currently is not `deletedResolveInfo` in ``parent``'s `reference` at `index`.

.Technical name
`deleteReferenceResolveInfo`

.Related event
<<evnt-referenceResolveInfoDeleted>>

[[cmd-changeReferenceResolveInfo]]
===== Change reference ResolveInfo
Change ResolveInfo of existing entry inside ``parent``'s `reference` at `index` from `oldResolveInfo` to `newResolveInfo`.

****
`target` MAY be `null` as we can only change ResolveInfo if both `oldResolveInfo` and `newResolveInfo` is non-`null`.
****

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newResolveInfo:: <<resolveInfoType>>
target:: <<targetNodeType>>?
oldResolveInfo:: <<resolveInfoType>>
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `newResolveInfo` is `null`
* `oldResolveInfo` is `null`
* ##?## resolveInfo is not set in ``parent``'s `reference` at `index`
* ##?## resolveInfo currently is not `oldResolveInfo` in ``parent``'s `reference` at `index`

.Technical name
`changeReferenceResolveInfo`

.Related event
<<evnt-referenceResolveInfoChanged>>

[[cmd-addReferenceTarget]]
===== Add reference target
Add `newTarget` as target to existing entry inside ``parent``'s `reference` at `index` with `resolveInfo`.

****
`resolveInfo` MUST NOT be `null` as we can only add target if target is `null`, and at least one of target and ResolveInfo MUST always be non-`null`.
****

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newTarget:: <<targetNodeType>>
resolveInfo:: <<resolveInfoType>>
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `newTarget` is `null`
* ##?## target already set in ``parent``'s `reference` at `index`.

.Technical name
`addReferenceTarget`

.Related event
<<evnt-referenceTargetAdded>>

[[cmd-deleteReferenceTarget]]
===== Delete reference target
Delete existing `deletedTarget` as target from existing entry inside ``parent``'s `reference` at `index` with `resolveInfo`.

****
`resolveInfo` MUST NOT be `null` as we're about to remove target, and at least one of target and ResolveInfo MUST always be non-`null`.
****

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
resolveInfo:: <<resolveInfoType>>
deletedTarget:: <<targetNodeType>>
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `deletedTarget` is `null`
* ##?## target is not set in ``parent``'s `reference` at `index`.
* ##?## target currently is not `deletedTarget` in ``parent``'s `reference` at `index`.

.Technical name
`deleteReferenceTarget`

.Related event
<<evnt-referenceTargetDeleted>>

[[cmd-changeReferenceTarget]]
===== Change reference target
Change target of existing entry inside ``parent``'s `reference` at `index` with `resolveInfo` from `oldTarget` to `newTarget`.

****
`resolveInfo` MAY be `null` as we can only change target if both `oldTarget` and `newTarget` is non-`null`.
****

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newTarget:: <<targetNodeType>>
resolveInfo:: <<resolveInfoType>>?
oldTarget:: <<targetNodeType>>
commandId:: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `newTarget` is `null`
* `oldTarget` is `null`
* ##?## target is not set in ``parent``'s `reference` at `index`
* ##?## target currently is not `oldTarget` in ``parent``'s `reference` at `index`

.Technical name
`changeReferenceTarget`

.Related event
<<evnt-referenceTargetChanged>>

[[cmd-composite-section]]
==== Composite

[[cmd-composite]]
===== Composite
Groups several commands into a logical group.
The parts are ordered.

Command groups don't guarantee anything; the repository MAY take the group as a hint to resolve conflicts in a different manner.

[horizontal]
.Parameters
parts:: <<commandType>>[]
commandId:: <<commandIdType>>

.Errors
* accumulation of all errors of `parts`

.Technical name
`composite`

.Related event
<<evnt-composite>>

[[events]]
=== Events

[[evnt-partitions]]
==== Partitions

[[evnt-partitionAdded]]
===== Partition added
Partition `newPartition` has been added to the repository.

This client is now subscribed to any changes to `newPartition` or any of its descendants.

[horizontal]
.Parameters
newPartition:: <<nodeType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`partitionAdded`

.Related command
<<cmd-addPartition>>

[[evnt-partitionDeleted]]
===== Partition deleted
Partition `deletedPartition`, and all its descendants, have been deleted from the repository.

This client is now unsubscribed from any changes to `deletedPartition` or any of its descendants.

[horizontal]
.Parameters
deletedPartition:: <<nodeType>> or <<targetNodeType>> #TODO#
originCommands:: <<commandSourceType>>[]

.Technical name
`partitionDeleted`

.Related command
<<cmd-deletePartition>>

[[evnt-nodes]]
==== Nodes

[[evnt-conceptChanged]]
===== Concept changed
Concept of `node` has been changed from `oldConcept` to `newConcept`.

[horizontal]
.Parameters
node:: <<targetNodeType>>
newConcept:: <<metaPointerType>>
oldConcept:: <<metaPointerType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`conceptChanged`

.Related command
<<cmd-changeClassifier>>

[[evnt-properties]]
==== Properties

[[evnt-propertyAdded]]
===== Property added
`property` of `node` has been set to `newValue`.

[horizontal]
.Parameters
node:: <<targetNodeType>>
property:: <<metaPointerType>>
newValue:: <<propertyValueType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`propertyAdded`

.Related command
<<cmd-addProperty>>

[[evnt-propertyDeleted]]
===== Property deleted
Existing `property` of `node` with `oldValue` has been deleted.

[horizontal]
.Parameters
node:: <<targetNodeType>>
property:: <<metaPointerType>>
oldValue:: <<propertyValueType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`propertyDeleted`

.Related command
<<cmd-deleteProperty>>

[[evnt-propertyChanged]]
===== Property changed
Existing `property` of `node` has been changed from `oldValue` to `newValue`.

[horizontal]
.Parameters
node:: <<targetNodeType>>
property:: <<metaPointerType>>
newValue:: <<propertyValueType>>
oldValue:: <<propertyValueType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`propertyChanged`

.Related command
<<cmd-changeProperty>>

[[evnt-children]]
==== Children

[[evnt-childAdded]]
===== Child added
New node `newChild` has been added to ``parent``'s  `containment` at `index`.
All other children inside ``parent``'s `containment` with index >= `index` have been moved to next higher index.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
newChild:: <<nodeType>>
containment:: <<metaPointerType>>
index:: <<indexType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`childAdded`

.Related command
<<cmd-addChild>>

[[evnt-childDeleted]]
===== Child deleted
Existing node `deletedChild`, and all its descendants, have been deleted from ``parent``'s `containment` at `index`.
All other children inside ``parent``'s `containment` with index > `index` have been moved to next lower index.

[horizontal]
.Parameters
deletedChild:: <<nodeType>> or <<targetNodeType>> #TODO#
parent:: <<targetNodeType>>
containment:: <<metaPointerType>>
index:: <<indexType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`childDeleted`

.Related command
<<cmd-deleteChild>>

[[evnt-childReplaced]]
===== Child replaced
Existing node `replacedChild` inside ``parent``'s `containment` at `index` has been replaced with new node `newChild`.
`replacedChild`, and all its descendants, have been deleted.

[horizontal]
.Parameters
newChild:: <<nodeType>>
replacedChild:: <<nodeType>> or <<targetNodeType>> #TODO#
parent:: <<targetNodeType>>
containment:: <<metaPointerType>>
index:: <<indexType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`childReplaced`

.Related command
<<cmd-replaceChild>>

[[evnt-childMovedFromOtherContainment]]
===== Child moved from other containment
Existing node `movedChild` (previously inside ``oldParent``'s `oldContainment` at `oldIndex`) has been moved
inside ``newParent``'s `newContainment` at `newIndex`.

All other children inside ``oldParent``'s `oldContainment` with index > `oldIndex` have been moved to next lower index.

All other children inside ``newParent``'s `newContainment` with index >= `newIndex` have been moved to next higher index.

[horizontal]
.Parameters
newParent:: <<targetNodeType>>
newContainment:: <<metaPointerType>>
newIndex:: <<indexType>>
movedChild:: <<targetNodeType>>
oldParent:: <<targetNodeType>>
oldContainment:: <<metaPointerType>>
oldIndex:: <<indexType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`childMovedFromOtherContainment`

.Related command
<<cmd-moveChildFromOtherContainment>>

[[evnt-childMovedFromOtherContainmentInSameParent]]
===== Child moved from other containment in same parent
Existing node `movedChild` (previously inside ``parent``'s `oldContainment` at `oldIndex`) has been moved
inside ``parent``'s `newContainment` at `newIndex`.

All other children inside ``parent``'s `oldContainment` with index > `oldIndex` have been moved to next lower index.

All other children inside ``parent``'s `newContainment` with index >= `newIndex` have been moved to next higher index.

[horizontal]
.Parameters
newContainment:: <<metaPointerType>>
newIndex:: <<indexType>>
movedChild:: <<targetNodeType>>
parent:: <<targetNodeType>>
oldContainment:: <<metaPointerType>>
oldIndex:: <<indexType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`childMovedFromOtherContainmentInSameParent`

.Related command
<<cmd-moveChildFromOtherContainmentInSameParent>>

[[evnt-childMovedInSameContainment]]
===== Child moved in same containment
Existing node `movedChild` (previously inside ``parent``'s `containment` at `oldIndex`) has been moved
inside ``parent``'s `containment` at `newIndex`.

If `oldIndex` < `newIndex`: All other children inside ``parent``'s `containment` with previous index > `oldIndex` and previous index <= `newIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=5`: `A[0] B[1] C[2] _D[3] E[4]_ *X[5]* F[6]`

If `oldIndex` > `newIndex`: All other children inside ``parent``'s `containment` with previous index >= `newIndex` and previous index < `oldIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=1`: `A[0] *X[1]* _B[2] C[3]_ D[4] E[5] F[6]`

`oldIndex` MUST NOT be equal to `newIndex`.

[horizontal]
.Parameters
newIndex:: <<indexType>>
movedChild:: <<targetNodeType>>
parent:: <<targetNodeType>>
containment:: <<metaPointerType>>
oldIndex:: <<indexType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`childMovedInSameContainment`

.Related command
<<cmd-moveChildInSameContainment>>

[[evnt-annotations]]
==== Annotations

[[evnt-annotationAdded]]
===== Annotation added
New node `newAnnotation` has been added to ``parent``'s annotations at `index`.
All other annotations inside ``parent``'s annotations with index >= `index` have been moved to next higher index.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
newAnnotation:: <<nodeType>>
index:: <<indexType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`annotationAdded`

.Related command
<<cmd-addAnnotation>>

[[evnt-annotationDeleted]]
===== Annotation deleted
Existing node `deletedAnnotation`, and all its descendants, have been deleted from ``parent``'s annotations at `index`.
All other annotations inside ``parent``'s annotations with index > `index` have been moved to next lower index.

[horizontal]
.Parameters
deletedAnnotation:: <<nodeType>> or <<targetNodeType>> #TODO#
parent:: <<targetNodeType>>
index:: <<indexType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`annotationDeleted`

.Related command
<<cmd-deleteAnnotation>>

[[evnt-annotationReplaced]]
===== Annotation replaced
Existing node `replacedAnnotation` inside ``parent``'s annotations at `index` has been replaced with new node `newAnnotation`.
`replacedAnnotation`, and all its descendants, have been deleted.

[horizontal]
.Parameters
newAnnotation:: <<nodeType>>
replacedAnnotation:: <<nodeType>> or <<targetNodeType>> #TODO#
parent:: <<targetNodeType>>
index:: <<indexType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`annotationReplaced`

.Related command
<<cmd-replaceAnnotation>>

[[evnt-annotationMovedFromOtherParent]]
===== Annotation moved from other parent
Existing node `movedAnnotation` (previously inside ``oldParent``'s annotations at `oldIndex`) has been moved
inside ``newParent``'s annotations at `newIndex`.

All other annotations inside ``oldParent``'s annotations with index > `oldIndex` have been moved to next lower index.

All other annotations inside ``newParent``'s annotations with index >= `newIndex` have been moved to next higher index.

[horizontal]
.Parameters
newParent:: <<targetNodeType>>
newIndex:: <<indexType>>
movedAnnotation:: <<targetNodeType>>
oldParent:: <<targetNodeType>>
oldIndex:: <<indexType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`annotationMovedFromOtherParent`

.Related command
<<cmd-moveAnnotationFromOtherParent>>

[[evnt-annotationMovedInSameParent]]
===== Annotation moved in same parent
Existing node `movedAnnotation` (previously inside ``parent``'s annotations at `oldIndex`) has been moved
inside ``parent``'s annotations at `newIndex`.

If `oldIndex` < `newIndex`: All other annotations inside ``parent``'s annotations with previous index > `oldIndex` and previous index <= `newIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=5`: `A[0] B[1] C[2] _D[3] E[4]_ *X[5]* F[6]`

If `oldIndex` > `newIndex`: All other annotations inside ``parent``'s annotations with previous index >= `newIndex` and previous index < `oldIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=1`: `A[0] *X[1]* _B[2] C[3]_ D[4] E[5] F[6]`

`oldIndex` MUST NOT be equal to `newIndex`.

[horizontal]
.Parameters
newIndex:: <<indexType>>
movedAnnotation:: <<targetNodeType>>
parent:: <<targetNodeType>>
oldIndex:: <<targetNodeType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`annotationMovedInSameParent`

.Related command
<<cmd-moveAnnotationInSameParent>>

[[evnt-references]]
==== References

[[evnt-referenceAdded]]
===== Reference added
Reference with `newTarget`/`newResolveInfo` has been added to ``parent``'s `reference` at `index`.
All other entries inside ``parent``'s `reference` with index >= `index` have been moved to next higher index.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newTarget:: <<targetNodeType>>?
newResolveInfo:: <<resolveInfoType>>?
originCommands:: <<commandSourceType>>[]

.Technical name
`referenceAdded`

.Related command
<<cmd-addReference>>

[[evnt-referenceDeleted]]
===== Reference deleted
Existing reference with `deletedTarget`/`deletedResolveInfo` has been deleted from ``parent``'s `reference` at `index`.
All other entries inside ``parent``'s `reference` with index > `index` have been moved to next lower index.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
deletedTarget:: <<targetNodeType>>
deletedResolveInfo:: <<resolveInfoType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`referenceDeleted`

.Related command
<<cmd-deleteReference>>

[[evnt-referenceChanged]]
===== Reference changed
Existing reference with `replacedTarget`/`replacedResolveInfo` inside ``parent``'s annotations at `index` has been replaced with `newTarget`/`newResolveInfo`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newTarget:: <<targetNodeType>>?
newResolveInfo:: <<targetNodeType>>?
replacedTarget:: <<targetNodeType>>
replacedResolveInfo:: <<resolveInfoType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`referenceChanged`

.Related command
<<cmd-changeReference>>

[[evnt-entryMovedFromOtherReference]]
===== Entry moved from other reference
Existing reference `target`/`resolveInfo` (previously inside ``oldParent``'s `oldReference` at `oldIndex`) has been moved
to ``newParent``'s `newReference` at `newIndex`.

All other entries inside ``oldParent``'s `oldReference` with index > `oldIndex` have been moved to next lower index.

All other entries inside ``newParent``'s `newReference` with index >= `newIndex` have been moved to next higher index.

[horizontal]
.Parameters
newParent:: <<targetNodeType>>
newReference:: <<metaPointerType>>
newIndex:: <<indexType>>
oldParent:: <<targetNodeType>>
oldReference:: <<metaPointerType>>
oldIndex:: <<indexType>>
target:: <<targetNodeType>>
resolveInfo:: <<resolveInfoType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`entryMovedFromOtherReference`

.Related command
<<cmd-moveEntryFromOtherReference>>

[[evnt-entryMovedFromOtherReferenceInSameParent]]
===== Entry moved from other reference in same parent
Existing reference `target`/`resolveInfo` (previously inside ``parent``'s `oldReference` at `oldIndex`) has been moved
to ``parent``'s `newReference` at `newIndex`.

All other entries inside ``parent``'s `oldReference` with index > `oldIndex` have been moved to next lower index.

All other entries inside ``parent``'s `newReference` with index >= `newIndex` have been moved to next higher index.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
newReference:: <<metaPointerType>>
newIndex:: <<indexType>>
oldReference:: <<metaPointerType>>
oldIndex:: <<indexType>>
target:: <<targetNodeType>>
resolveInfo:: <<resolveInfoType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`entryMovedFromOtherReferenceInSameParent`

.Related command
<<cmd-moveEntryFromOtherReferenceInSameParent>>

[[evnt-entryMovedInSameReference]]
===== Entry moved in same reference
Existing reference `target`/`resolveInfo` (previously inside ``parent``'s `reference` at `oldIndex`) has been moved
to ``parent``'s `reference` at `newIndex`.

If `oldIndex` < `newIndex`: All other entries inside ``parent``'s `reference` with previous index > `oldIndex` and previous index <= `newIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=5`: `A[0] B[1] C[2] _D[3] E[4]_ *X[5]* F[6]`

If `oldIndex` > `newIndex`: All other entries inside ``parent``'s `reference` with previous index >= `newIndex` and previous index < `oldIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=1`: `A[0] *X[1]* _B[2] C[3]_ D[4] E[5] F[6]`

`oldIndex` MUST NOT be equal to `newIndex`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
oldIndex:: <<indexType>>
newIndex:: <<indexType>>
target:: <<targetNodeType>>
resolveInfo:: <<resolveInfoType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`entryMovedInSameReference`

.Related command
<<cmd-moveEntryInSameReference>>

[[evnt-referenceResolveInfoAdded]]
===== Reference ResolveInfo added
`newResolveInfo` has been added as ResolveInfo to existing entry inside ``parent``'s `reference` at `index` with `target`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newResolveInfo:: <<resolveInfoType>>
target:: <<targetNodeType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`referenceResolveInfoAdded`

.Related command
<<cmd-addReferenceResolveInfo>>

[[evnt-referenceResolveInfoDeleted]]
===== Reference ResolveInfo deleted
ResolveInfo `deletedResolveInfo` has been deleted from existing entry inside ``parent``'s `reference` at `index` with `target`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
target:: <<targetNodeType>>
deletedResolveInfo:: <<resolveInfoType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`referenceResolveInfoDeleted`

.Related command
<<cmd-deleteReferenceResolveInfo>>

[[evnt-referenceResolveInfoChanged]]
===== Reference ResolveInfo changed
ResolveInfo of existing entry inside ``parent``'s `reference` at `index` with `target` has been changed from `oldResolveInfo` to `newResolveInfo`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newResolveInfo:: <<resolveInfoType>>
target:: <<targetNodeType>>?
replacedResolveInfo:: <<resolveInfoType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`referenceResolveInfoChanged`

.Related command
<<cmd-changeReferenceResolveInfo>>

[[evnt-referenceTargetAdded]]
===== Reference target added
`newTarget` has been added as target to existing entry inside ``parent``'s `reference` at `index` with `resolveInfo`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newTarget:: <<targetNodeType>>
resolveInfo:: <<resolveInfoType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`referenceTargetAdded`

.Related command
<<cmd-addReferenceTarget>>

[[evnt-referenceTargetDeleted]]
===== Reference target deleted
Target `deletedTarget` has been deleted from existing entry inside ``parent``'s `reference` at `index` with `resolveInfo`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
resolveInfo:: <<resolveInfoType>>
deletedTarget:: <<targetNodeType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`referenceTargetDeleted`

.Related command
<<cmd-deleteReferenceTarget>>

[[evnt-referenceTargetChanged]]
===== Reference target changed
Target of existing entry inside ``parent``'s `reference` at `index` with `resolveInfo` has been changed from `oldTarget` to `newTarget`.

[horizontal]
.Parameters
parent:: <<targetNodeType>>
reference:: <<metaPointerType>>
index:: <<indexType>>
newTarget:: <<targetNodeType>>
resolveInfo:: <<resolveInfoType>>?
replacedTarget:: <<targetNodeType>>
originCommands:: <<commandSourceType>>[]

.Technical name
`referenceTargetChanged`

.Related command
<<cmd-changeReferenceTarget>>

[[evnt-miscellaneous]]
==== Miscellaneous

[[evnt-composite]]
===== Composite
The events in `parts` have happened in the given order.

All `originCommands` have been handled (maybe by discarding them).

[horizontal]
.Parameters
parts:: <<eventType>>[]
originCommands:: <<commandSourceType>>[]

.Technical name
`composite`

.Related command
<<cmd-composite>>

[[evnt-noOp]]
===== No-op
Nothing happened as result of one or more command(s).

[horizontal]
.Parameters
originCommands:: <<commandSourceType>>[]

.Technical name
`noOp`

.Related command
_none_

[[evnt-error]]
===== Error
Repository couldn't handle one or more command(s).

[horizontal]
.Parameters
errorCode:: `String`
message:: `String`
originCommands:: <<commandSourceType>>[]

.Technical name
`error`

.Related command
_none_
