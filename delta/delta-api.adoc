include::../shared/issue-footnotes.adoc[]
:serialization: ../serialization/serialization
:m3: ../metametamodel/metametamodel
:bulk: ../bulk/repo-access-api
:arch: ../reference-architecture/reference-architecture
:chunk: <<{serialization}.adoc#SerializationChunk, SerializationChunk>>

[[delta]]
= Delta Repository Access API
:toc: preamble
:toclevels: 4
:sectnumlevels: 4
:sectnums:
:!figure-caption:

The delta API *version 2024.1* is used to store and retrieve changes to nodes.
It is intended for fine-grained changes to single values.
it is *not* intended as a bulk API that updates large chunks of the model at once.

== Conventions used in this document
* ALL-CAPS key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in https://datatracker.ietf.org/doc/html/bcp14[BCP14] (https://datatracker.ietf.org/doc/html/rfc2119[RFC2119], https://datatracker.ietf.org/doc/html/rfc8174[RFC8174]) when, and only when, they appear in all capitals, as shown here.
* Footnotes refer to more discussions and rationale, but are non-normative.

== Introduction
Delta API assumes a bidirectional communication channel.
The _client_ initiates the channel with the _repository_ to open a _session_.
Both parties communicate through the established channel via _messages_.

Delta API supports these message kinds, loosely following CQRS patternfootnote:[https://en.wikipedia.org/wiki/Command_Query_Responsibility_Segregation]:

* <<queries>> initiated/requested by the client, with synchronous response by the repository.
A query requests some information from the repository without changing the repository's contents.
The repository gathers all information needed to answer the query, and sends the information back.
The repository might reply invalid queries with a failure message.

* <<commands>> initiated/requested by the client, with synchronous response by the repository.
A command requests some change to the repository.
The repository quickly confirms having _received_ the command, or rejects a _failed_ command.
However, the repository processes the command asynchronously, and eventually broadcasts the effect(s) as _event_.

* <<events>> initiated/broadcast by the repository, without response by the client.
An event describes some change that has been applied to the repository's contents.
Events correlate to their originating command(s); this command might have been sent by this client or another client.
All clients receive the same events (given the same _subscription scope_, see below).

* Session messages for bookkeeping.

A client describes the interesting part of the repository's contents by specifying its _subscription scope_.
The client receives only events on nodes within that scope.
Scope is defined by the node id of a <<{m3}.adoc#partition, partition>>; it includes all changes to the partition and all its descendants (including annotation instances).

A typical workflow for a client would be:

1. Client connects to repository and starts a session.
2. Client subscribes to some partitions with subscription queries.
The response contains a <<{serialization}.adoc#SerializationChunk, serialization chunk>> with the current contents of these partitions.
3. Client initiates its editor or processing with the chunk.
4. Client sends commands to request changes to some nodes in the subscribed partitions.
5. Client receives events with the actual changes that have been applied to the subscribed nodes.
6. Client updates its editor or processing with the event's contents.
7. Client receives events originating from other clients' commands.
8. Client updates its editor or processing with the event's contents.
9. Client ends the session.

The repository is always the ultimate arbiter of its contents.
It can decide to apply each command verbatim, with some tweaks (e.g. because of concurrent changes), or not at all (e.g. because the command would introduce containment loops).

Each repository might introduce its own strategy how to handle commands.
For example, assume client 1 sends a `deleteChild` command to delete node `X`, and then client 2 sends a `setProperty` command on node `X`. +
Repository A applies all commands in order, thus deletes node `X` and ignores the second command.
It emits one `childDeleted` event, correlated to both commands. +
Repository B keeps an internal "trash can" of all deleted nodes.
It deletes node `X` on the first command, but resurrects node `X` on the second command and changes the property as requested.
It first emits a `childDeleted` event (correlated to the first command), but later `childAdded` and `propertyChanged` events (both correlated to the second command). +
Repository C batches command processing.
It looks at both messages together, and decides it's more important to keep the new property value around.
It emits one `propertyChanged` event, correlated with both commands.

A client stays up-to-date with the repository's contents if it applies all events in order.
A client can either decide to apply its own change immediately and filter out events based on that command, or wait for the correlated event to arrive and apply the change only then.

=== Command overview

[cols="2,3,3,3,1,1"]
|===
|Action |Child |Annotation |Reference |Property |Partition / Classifier

|Add
|<<cmd-addChild>>
|<<cmd-addAnnotation>>
|
<<cmd-addReference>>

<<cmd-addReferenceResolveInfo>>

<<cmd-addReferenceTarget>>
|<<cmd-addProperty>>
|<<cmd-addPartition>>

|Delete
|<<cmd-deleteChild>>
|<<cmd-deleteAnnotation>>
|
<<cmd-deleteReference>>

<<cmd-deleteReferenceResolveInfo>>

<<cmd-deleteReferenceTarget>>
|<<cmd-deleteProperty>>
|<<cmd-deletePartition>>

|Change
|<<cmd-replaceChild>>
|<<cmd-replaceAnnotation>>
|
<<cmd-changeReference>>

<<cmd-changeReferenceResolveInfo>>

<<cmd-changeReferenceTarget>>
|<<cmd-changeProperty>>
|<<cmd-changeClassifier>>

|Move from other node
|<<cmd-moveChildFromOtherContainment>>
|<<cmd-moveAnnotationFromOtherParent>>
|<<cmd-moveEntryFromOtherReference>>
|
|

|Move from other feature in same node
|<<cmd-moveChildFromOtherContainmentInSameParent>>
|
|<<cmd-moveEntryFromOtherReferenceInSameParent>>
|
|

|Move in same feature in same node
|<<cmd-moveChildInSameContainment>>
|<<cmd-moveAnnotationInSameParent>>
|<<cmd-moveEntryInSameReference>>
|
|

|Move from other node and replace existing
|<<cmd-moveAndReplaceChildFromOtherContainment>>
|<<cmd-moveAndReplaceAnnotationFromOtherParent>>
|<<cmd-moveAndReplaceEntryFromOtherReference>>
|
|

|Move from other feature in same node and replace existing
|<<cmd-moveAndReplaceChildFromOtherContainmentInSameParent>>
|
|<<cmd-moveAndReplaceEntryFromOtherReferenceInSameParent>>
|
|

|Move in same feature in same node and replace existing
|<<cmd-moveAndReplaceChildInSameContainment>>
|<<cmd-moveAndReplaceAnnotationInSameParent>>
|<<cmd-moveAndReplaceEntryInSameReference>>
|
|

|Composite
5+|<<cmd-composite>>
|===


== Description
=== Client characteristics
A client MUST identify with the repository with a _client id_.
The client id MUST be a valid <<{m3}.adoc#node-id, identifier>>.
It serves as a technical identifier.
Authentication and authorization are out of scope of this API.

=== Channel characteristics
Logically, the channel has independent parts for each kind of message;
in practice, we might transmit some or all of them through a shared channel.

This protocol is agnostic of its underlying technical implementation.
We can use any (e.g. stateless, stateful) protocol, as long as it fulfills request/response characteristics for client-initiated query, command, and session messages, and repository-initiated broadcast characteristics for event messages.

[[session, session]]
=== Session characteristics
One client may have more than one open session.
The client has the responsibility to guarantee uniqueness of query / command / session message ids.

=== Message characteristics
Each message is atomic; it cannot be split.

We assume the underlying protocol handles quality of service concerns (e.g. guaranteed one-time complete delivery of messages), they are out of scope of this API.

Each message has some id unique to the session:

* Queries have a _query id_.
* Commands have a _command id_.
* Events have _origin commands_.

== Open questions
#TODO#

* For new nodes, do we only send their id + classifier, or a complete node?

* Which of the events can potentially create invalid (recursively contained) trees?

* Which kind of errors do we accept?
How does this interact with concurrent edits?
Example: Does <<cmd-deleteChild>> fail if the `removedChild` does not exist?

* in removal cases (e.g. <<cmd-deleteChild>>), do we want to send only the removed id or the whole node?

* Do we need "swapNodes" event?

* Wording for commands/events: Shall we use "deleteXxx" everywhere? Or "removeXxx"? Or "deleteXxx" for deleting nodes, and "removeXxx" for removing properties / references?

* Decide on errors marked with #?# (invalid optional parameter values){fn-org312}

* How to report a command has completely been discarded, without any resulting event?{fn-org314}

== Scenarios
include::scenarios/virginRepo.adoc[]

include::scenarios/reconnectKnownPartition.adoc[]

include::scenarios/changeKnownNodeRemoteUpdate.adoc[]

include::scenarios/changeKnownNodeLocalUpdate.adoc[]

include::scenarios/changeUnknownNodeFailedCommand.adoc[]

include::scenarios/changeUnknownNodeFailedEvent.adoc[]

include::scenarios/changeSameValueRemoteUpdate.adoc[]

include::scenarios/repositoryBug.adoc[]

include::scenarios/concurrentChangeLocalUpdate.adoc[]

include::scenarios/concurrentChangeRemoteUpdate.adoc[]

== Messages
=== Parameter types
[horizontal]
[[nodeType]]Node:: Whole node encoded as <<{serialization}.adoc#node, node>>.

[[targetNodeType]]TargetNode:: Target's node as <<{m3}.adoc#identifiers, id>>.

[[metaPointerType]]MetaPointer:: MetaPointer-tuple to describe an M2 element (classifier, feature, etc.).
Encoded as <<{serialization}.adoc#meta-pointer, meta-pointer>>.

[[propertyValueType]]PropertyValue:: Property value encoded as <<{serialization}.adoc#property-values, property value>>.

[[resolveInfoType]]ResolveInfo:: ResolveInfo of a reference as string.
Can be `null`.

[[indexType]]Index:: Position inside a multiple link or annotations as integer >= 0.
Cannot be `null`.
Use value `0` for <<{m3}.adoc#multiplicity, single links>>.

[[commandType]]Command:: Any <<commands, command>>.

[[commandIdType]]CommandId:: Id of a command.{fn-org305}
Same format as <<{m3}.adoc#identifiers, node ids>>; must be unique per <<session>>.

[[queryIdType]]QueryId:: Id of a query.
Same format as <<{m3}.adoc#identifiers, node ids>>; must be unique per <<session>>.

[[chunkType]]SerializationChunk:: <<{serialization}.adoc, Chunk of nodes>>.

[[eventType]]Event:: Any <<events, event>>.

[[commandSourceType]]CommandSource:: _[clientId, commandId]_ tuple{fn-org306} this event is based on.
This allows a client to know when its command has been processed (either successful or not).

[[freeIdType]]FreeId:: Free <<{m3}.adoc#identifiers, node id>>.

==== How to calculate a CommandSource
`commandSource = base64urlEncode(sha256(concat(clientId, commandId)))`{fn-org306}

1. Concatenate the `clientId` and `commandId`
2. Calculate sha256 hash of that concatenated string
3. Encode the hash with base64url scheme.

Rationale: The originating client for this command does know both the client id and command id.
The same applies for the repository, but NOT other clients.
So the originating client and the repository can calculate the `commandSource`, but not any other client.
Thus, the command -- event correlation is possible for the originating client without revealing any origin information to other clients.

==== How to address references
We refer to references by the tuple of _[parent, reference, index]_.
Rationale: Both reference `target` and `resolveInfo` can be `null`, so they aren't suitable for identifying the reference.
However, `target` and `resolveInfo` MUST NOT both be `null`.


include::queries.adoc[]

include::commandEventOverview/command-event-overview.adoc[]

include::commands.adoc[]

include::events.adoc[]
