include::../shared/issue-footnotes.adoc[]
:serialization: ../serialization/serialization
:m3: ../metametamodel/metametamodel
:bulk: ../bulk/repo-access-api
:arch: ../reference-architecture/reference-architecture
:chunk: <<{serialization}.adoc#SerializationChunk, SerializationChunk>>

[[delta]]
= Delta Repository Access API
:toc: preamble
:toclevels: 4

The delta API *version 2024.1* is used to store and retrieve changes to nodes.
It is intended for fine-grained changes to single values.
it is *not* intended as a bulk API that updates large chunks of the model at once.

== Conventions used in this document
* ALL-CAPS key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in https://datatracker.ietf.org/doc/html/bcp14[BCP14] (https://datatracker.ietf.org/doc/html/rfc2119[RFC2119], https://datatracker.ietf.org/doc/html/rfc8174[RFC8174]) when, and only when, they appear in all capitals, as shown here.
* Footnotes refer to more discussions and rationale, but are non-normative.

== Open questions{fn-org280}:
#TODO#

* For new nodes, do we only send their id + classifier, or a complete node?

* Which of the events can potentially create invalid (recursively contained) trees?

* Which kind of errors do we accept?
How does this interact with concurrent edits?
Example: Does <<cmd-deleteChild>> fail if the `removedChild` does not exist?

* in removal cases (e.g. <<cmd-deleteChild>>), do we want to send only the removed id or the whole node?

* Do we need "swapNodes" event?

* Wording for commands/events: Shall we use "deleteXxx" everywhere? Or "removeXxx"? Or "deleteXxx" for deleting nodes, and "removeXxx" for removing properties / references?

* Decide on errors marked with #?# (invalid optional parameter values){fn-org312}

* How to report a command has completely been discarded, without any resulting event?

== Scenarios

=== Virgin repository, first time client connects

[plantuml,virginRepo,svg]
----
hide footbox
autonumber

box "Client A"
  participant Editor as editor
'  participant Queries as cQry
  participant Events as clientEvent
  participant Commands as clientCmd
  participant Session as clientSession
end box

box "Repository"
  participant Session as repoSession
  participant Commands as repoCmd
'  participant Queries  as rQry
  participant Events as repoEvent
  participant Core as core
end box

== Client A unconnected ==

clientSession -> repoSession ++: connect("client-a")
return ok

[->> clientCmd ++
clientCmd -> repoCmd ++: addPartition(nodeA, "cmd-1")
repoCmd ->> core
activate core
clientCmd <-- repoCmd: received("cmd-1")
deactivate clientCmd
deactivate repoCmd

core -> core: update()

core -> repoEvent
deactivate core

activate repoEvent
clientEvent <<- repoEvent: partitionAdded(nodeA,\n  ["ZWUzN2Q0YTcwZjM4YzhjYzU3NmQ5YThk\n    NjczNTU0ODBmMDI4YTE0MjE4ZDU2MTRh\n    NGRjNTA3NmE1MTk3Y2U3ZiAgLQo\n  "])
deactivate repoEvent

activate clientEvent
clientEvent -> editor
deactivate clientEvent

activate editor
editor -> editor: draw(nodeA)
----

1. Client connects to repository with its client id `client-a`.
2. Repository confirms connection.
3. Client initiates new partition.
4. Client sends `addPartition` command with `nodeA` payload (details omitted) and command id `cmd-1`.
5. Repository registers command for processing.
6. Repository acknowledges reception of command with id `cmd-1`.
7. Repository updates internal representation.
8. Repository creates event for update.
9. Repository emits event `partitionAdded` with `nodeA` payload.
It includes one <<commandSourceType>> with value `base64url(sha256("client-acmd-1"))`
10. Client receives event and forwards information to editor.
11. Client draws `nodeA`.

=== Client reconnects to known partition

[plantuml,reconnectKnownPartition,svg]
----
hide footbox
autonumber

box "Client A"
  participant Editor as editor
  participant Queries as clientQuery
end box

box "Repository"
  participant Queries  as repoQuery
  participant Core as core
end box

== Client A connected with client id "client-a" ==

[->> clientQuery
activate clientQuery
clientQuery -> repoQuery ++: subscribePartition("partition-id", "qry-1")
  repoQuery -> core ++: retrieveDescendants("partition-id")
  return
return content: [partitionNode, childNodeA, childNodeB]\nqueryId: "qry-1"
clientQuery -> editor
deactivate clientQuery
activate editor
editor -> editor: draw(childNodeA, childNodeB)
----
1. Client knows the relevant partition, wants to subscribe.
2. Client sends `subscribePartition` query with partition node id `partition-id`.
3. Repository retrieves all contents of partition with node id `partition-id`.
4. Repository found contents.
5. Repository responds to query with id `qry-1` with contents of 3 nodes: `partitionNode`, `childNodeA`, `childNodeB` (details omitted).
6. Client receives query result and forwards information to editor.
7. Client draws `childNodeA` and `childNodeB`.
`partitionNode` is not drawn, it represents the canvas.

=== Client changes known node with remote update

[plantuml,changeKnownNodeRemoteUpdate,svg]
----
hide footbox
autonumber

box "Client A"
  participant Editor as editor
  participant Events as clientEvent
  participant Commands as clientCmd
end box

box "Repository"
  participant Commands as repoCmd
  participant Events as repoEvent
  participant Core as core
end box

== Client A connected with client id "client-a"\nsubscribed to "partition-id"\nknows about nodeA (part of "partition-id") ==

[->> editor ++
editor -> clientCmd ++
clientCmd -> repoCmd ++: addProperty("nodeA", age, "23", "cmd-1")
repoCmd ->> core
activate core
clientCmd <-- repoCmd: received("cmd-1")
deactivate repoCmd
editor <-- clientCmd
deactivate clientCmd
deactivate editor

core -> core: update()

core -> repoEvent
deactivate core

activate repoEvent
clientEvent <<- repoEvent: propertyAdded("nodeA", age, "23",\n  ["ZWUzN2Q0YTcwZjM4YzhjYzU3NmQ5YThk\n    NjczNTU0ODBmMDI4YTE0MjE4ZDU2MTRh\n    NGRjNTA3NmE1MTk3Y2U3ZiAgLQo\n  "])
deactivate repoEvent

activate clientEvent
clientEvent -> editor
deactivate clientEvent

activate editor
editor -> editor: update(nodeA.age = 23)
----
1. User enters new property value.
2. Client editor forwards user action into command.
3. Client sends `addProperty` command with `nodeA` node id, `age` property (details omitted), `23` value and command id `cmd-1`.
4. Repository registers command for processing.
5. Repository acknowledges reception of command with id `cmd-1`.
6. Client informs editor of command submission.
7. Repository updates internal representation.
8. Repository creates event for update.
9. Repository emits event `propertyAdded` with `nodeA` node id, `age` property (details omitted) and `23` value.
It includes one <<commandSourceType>> with value `base64url(sha256("client-acmd-1"))`
10. Client receives event and forwards information to editor.
11. Client updates `nodeA` with new property value.

=== Client changes known node with local update

[plantuml,changeKnownNodeLocalUpdate,svg]
----
hide footbox
autonumber

box "Client A"
  participant Editor as editor
  participant Events as clientEvent
  participant Commands as clientCmd
end box

box "Repository"
  participant Commands as repoCmd
  participant Events as repoEvent
  participant Core as core
end box

== Client A connected with client id "client-a"\nsubscribed to "partition-id"\nknows about nodeA (part of "partition-id") ==

[->> editor ++
editor -> editor: update(nodeA.age = 23)
editor ->> clientCmd
deactivate editor
activate clientCmd
clientCmd -> repoCmd ++: addProperty("nodeA", age, "23", "cmd-1")

repoCmd ->> core
activate core
clientCmd <-- repoCmd: received("cmd-1")
deactivate repoCmd

clientCmd -> clientEvent: registerProcessedCmd("cmd-1")
activate clientEvent
deactivate clientCmd
deactivate clientEvent

core -> core: update()

core -> repoEvent
deactivate core

activate repoEvent
clientEvent <<- repoEvent: propertyAdded("nodeA", age, "23",\n  ["ZWUzN2Q0YTcwZjM4YzhjYzU3NmQ5YThk\n    NjczNTU0ODBmMDI4YTE0MjE4ZDU2MTRh\n    NGRjNTA3NmE1MTk3Y2U3ZiAgLQo\n  "])
deactivate repoEvent

activate clientEvent
clientEvent -> clientEvent: checkForProcessedCmd()
clientEvent -> clientEvent: removeProcessedCmd("cmd-1")
deactivate clientEvent

core <<-]: addProperty(..., "cmd-x")
activate core
core -> core: update()

core -> repoEvent
deactivate core

activate repoEvent
clientEvent <<- repoEvent: propertyAdded(...\n  ["ZjJlM2FhMTVkZTllZjA1MmRiMzdjMzZj\n    YWE5YjVkYmUxMTI3ZmIzM2I0NDM3NTE1\n    MzgzNGYwMTczMTRkMDU5ZSAgLQo\n  "])
deactivate repoEvent

activate clientEvent
clientEvent -> clientEvent: checkForProcessedCmd()
clientEvent -> editor
deactivate clientEvent

activate editor
editor -> editor: update()
----
1. User enters new property value.
2. Client updates `nodeA` with new property value.
3. Client editor forwards user action into command.
4. Client sends `addProperty` command with `nodeA` node id, `age` property (details omitted), `23` value and command id `cmd-1`.
5. Repository registers command for processing.
6. Repository acknowledges reception of command with id `cmd-1`.
7. Client registers processed command id `cmd-1`.
8. Repository updates internal representation.
9. Repository creates event for update.
10. Repository emits event `propertyAdded` with `nodeA` node id, `age` property (details omitted) and `23` value.
It includes one <<commandSourceType>> with value `base64url(sha256("client-acmd-1"))`
11. Client calculates `base64url(sha256(concat(__clientId__, __commandId__))) for each registered processed command id.
12. Client found a matching registered processed command id.
Client unregisters processed command id `cmd-1`, and does NOT forward information to editor -- the event originates from this client, thus has already been processed.
13. Another client sends `addProperty` command with command id `cmd-x` (other parameters omitted).
14. Repository updates internal representation.
15. Repository creates event for update.
16. Repository emits event `propertyAdded` with `nodeA` node id, `age` property (details omitted) and `23` value.
It includes one <<commandSourceType>> with value `base64url(sha256("client-acmd-x"))`
17. Client calculates `base64url(sha256(concat(__clientId__, __commandId__))) for each registered processed command id.
18. Client did not find any matching registered processed command id.
Client forwards information to editor.
19. Client updates with new property value.

=== Client tries to change unknown node with failed command

[plantuml,changeUnknownNodeFailedCommand,svg]
----
hide footbox
autonumber

box "Client A"
  participant Editor as editor
  participant Commands as clientCmd
end box

box "Repository"
  participant Commands as repoCmd
  participant Core as core
end box

== Client A connected with client id "client-a"\nsubscribed to "partition-id"\nassumes invalid nodeA (part of "partition-id") ==

[->> editor ++
editor -> clientCmd ++
clientCmd -> repoCmd ++: addProperty("nodeA", age, "23", "cmd-1")
repoCmd -> core ++: checkNodeId("nodeA")
return false
return failed("cmd-1", "unknown node id nodeA")
return
editor -> editor: DisplayError()
----
1. User enters new property value on node `nodeA` that's known to the editor.
2. Client editor forwards user action into command.
3. Client sends `addProperty` command with `nodeA` node id, `age` property (details omitted), `23` value and command id `cmd-1`.
4. Repository checks whether it knows a node with id `nodeA`.
5. Repository doesn't know that node.
6. Repository refuses command.
7. Client informs editor of failed command.
8. Client informs user.

=== Client tries to change unknown node with failed event

[plantuml,changeUnknownNodeFailedEvent,svg]
----
hide footbox
autonumber

box "Client A"
  participant Editor as editor
  participant Events as clientEvent
  participant Commands as clientCmd
end box

box "Repository"
  participant Commands as repoCmd
  participant Events as repoEvent
  participant Core as core
end box

== Client A connected with client id "client-a"\nsubscribed to "partition-id"\nassumes invalid nodeA (part of "partition-id") ==

[->> editor ++
editor -> clientCmd ++
clientCmd -> repoCmd ++: addProperty("nodeA", age, "23", "cmd-1")
repoCmd ->> core
activate core
clientCmd <-- repoCmd: received("cmd-1")
deactivate repoCmd
clientCmd -> clientEvent: registerProcessedCmd("cmd-1")
activate clientEvent
deactivate clientEvent
deactivate repoCmd
editor <-- clientCmd
deactivate clientCmd
deactivate editor

core -> core: unknownNodeId("nodeA")

== ????? ==
----
1. User enters new property value on node `nodeA` that's known to the editor.
2. Client editor forwards user action into command.
3. Client sends `addProperty` command with `nodeA` node id, `age` property (details omitted), `23` value and command id `cmd-1`.
4. Repository registers command for processing.
5. Repository acknowledges reception of command with id `cmd-1`.
6. Client registers processed command id `cmd-1`.
7. Client informs editor of command submission.
8. Repository realizes it does not know a node with id `nodeA`
9. #TODO# How does client know its `addProperty` failed?

=== Concurrent changes to known node with local update

[plantuml,concurrentChangeLocalUpdate,svg]
----
hide footbox
autonumber

box "Client A"
  participant Editor as editor
  participant Events as clientEvent
  participant Commands as clientCmd
end box

box "Repository"
  participant Commands as repoCmd
  participant Events as repoEvent
  participant Core as core
end box

== Client A connected with client id "client-a"\nsubscribed to "partition-id"\nknows about nodeA (part of "partition-id") ==

[->> editor ++
editor -> editor: update(nodeA.age = 23)
editor ->> clientCmd
deactivate editor
activate clientCmd
clientCmd -> repoCmd ++: addProperty("nodeA",\n  age, "23", "cmd-1")
repoCmd ->> core
activate core
clientCmd <-- repoCmd: received("cmd-1")
deactivate repoCmd
clientCmd -> clientEvent: registerProcessedCmd("cmd-1")
activate clientEvent
deactivate clientEvent
deactivate clientCmd

core <<-]: addProperty("nodeA",\n  age, "42", "cmd-x")

core -> core: resolveConcurrentUpdates()

core -> repoEvent
deactivate core

activate repoEvent
clientEvent <<- repoEvent: propertyAdded("nodeA", age, "42",\n  ["ZWUzN2Q0YTcwZjM4YzhjYzU3NmQ5YThk\n    NjczNTU0ODBmMDI4YTE0MjE4ZDU2MTRh\n    NGRjNTA3NmE1MTk3Y2U3ZiAgLQo",\n  "ZjJlM2FhMTVkZTllZjA1MmRiMzdjMzZj\n    YWE5YjVkYmUxMTI3ZmIzM2I0NDM3NTE1\n    MzgzNGYwMTczMTRkMDU5ZSAgLQo\n  "])
deactivate repoEvent

activate clientEvent
clientEvent -> clientEvent: checkForProcessedCmd()
clientEvent -> clientEvent: removeProcessedCmd("cmd-1")
clientEvent -> editor
deactivate clientEvent

activate editor
editor -> editor: update(nodeA.age = 42)
----
1. User enters new property value.
2. Client updates `nodeA` with new property value.
3. Client editor forwards user action into command.
4. Client sends `addProperty` command with `nodeA` node id, `age` property (details omitted), `23` value and command id `cmd-1`.
5. Repository registers command for processing.
6. Repository acknowledges reception of command with id `cmd-1`.
7. Client registers processed command id `cmd-1`.
8. Another client sends `addProperty` command `nodeA` node id, `age` property (details omitted), `42` value and command id `cmd-x`.
9. Repository resolves concurrent updates t `nodeA`, `age` property with "last write wins" strategy.
Repository updates internal representation with value `42`.
10. Repository creates event for update.
11. Repository emits event `propertyAdded` with `nodeA` node id, `age` property (details omitted) and `23` value.
It includes one <<commandSourceType>> with values `base64url(sha256("client-acmd-1"))` and `base64url(sha256("client-acmd-x"))`.
12. Client calculates `base64url(sha256(concat(__clientId__, __commandId__)))` for each registered processed command id.
13. Client found a matching registered processed command id.
Client unregisters processed command id `cmd-1`.
14. Not all command sources could be matched against registered processed command ids.
Client forwards information to editor.
15. Client updates with new property value.

=== Concurrent changes to known node with remote update

[plantuml,concurrentChangeRemoteUpdate,svg]
----
hide footbox
autonumber

box "Client A"
  participant Editor as editor
  participant Events as clientEvent
  participant Commands as clientCmd
end box

box "Repository"
  participant Commands as repoCmd
  participant Events as repoEvent
  participant Core as core
end box

== Client A connected with client id "client-a"\nsubscribed to "partition-id"\nknows about nodeA (part of "partition-id") ==

[->> editor ++
editor -> clientCmd ++
clientCmd -> repoCmd ++: addProperty("nodeA", age, "23", "cmd-1")
repoCmd ->> core
activate core
clientCmd <-- repoCmd: received("cmd-1")
deactivate repoCmd
editor <-- clientCmd
deactivate clientCmd
deactivate editor

core <<-]: addProperty("nodeA",\n  age, "42", "cmd-x")

core -> core: resolveConcurrentUpdates()

core -> repoEvent
deactivate core

activate repoEvent
clientEvent <<- repoEvent: propertyAdded("nodeA", age, "42",\n  ["ZWUzN2Q0YTcwZjM4YzhjYzU3NmQ5YThk\n    NjczNTU0ODBmMDI4YTE0MjE4ZDU2MTRh\n    NGRjNTA3NmE1MTk3Y2U3ZiAgLQo",\n  "ZjJlM2FhMTVkZTllZjA1MmRiMzdjMzZj\n    YWE5YjVkYmUxMTI3ZmIzM2I0NDM3NTE1\n    MzgzNGYwMTczMTRkMDU5ZSAgLQo\n  "])
deactivate repoEvent

activate clientEvent
clientEvent -> editor
deactivate clientEvent

activate editor
editor -> editor: update(nodeA)
----
1. User enters new property value.
2. Client editor forwards user action into command.
3. Client sends `addProperty` command with `nodeA` node id, `age` property (details omitted), `23` value and command id `cmd-1`.
4. Repository registers command for processing.
5. Repository acknowledges reception of command with id `cmd-1`.
6. Client informs editor of command submission.
7. Another client sends `addProperty` command `nodeA` node id, `age` property (details omitted), `42` value and command id `cmd-x`.
8. Repository resolves concurrent updates t `nodeA`, `age` property with "last write wins" strategy.
Repository updates internal representation with value `42`.
9. Repository creates event for update.
10. Repository emits event `propertyAdded` with `nodeA` node id, `age` property (details omitted) and `23` value.
It includes one <<commandSourceType>> with values `base64url(sha256("client-acmd-1"))` and `base64url(sha256("client-acmd-x"))`.
11. Client receives event and forwards information to editor.
12. Client updates `nodeA` with new property value.


== Messages
=== Parameter types

[[nodeType]]Node:: Either the whole node as json, or its id + classifier #TODO#
[[targetNodeType]]TargetNode:: Target's node as id
[[metaPointerType]]MetaPointer:: MetaPointer-tuple to describe an M2 element (classifier, feature, etc.)
[[propertyValueType]]PropertyValue:: Property value encoded as string
[[resolveInfoType]]ResolveInfo:: ResolveInfo of a reference as string
[[indexType]]Index:: Position inside a multiple link or annotations as integer >= 0
[[commandType]]Command:: Any command
[[commandIdType]]CommandId:: Id of a command.{fn-org305}
Same format as node ids; must be unique per client and connection.
[[queryIdType]]QueryId:: Id of a query.
Same format as node ids; must be unique per client and connection.
[[chunkType]]SerializationChunk:: <<{serialization}.adoc, Chunk of nodes>>
[[eventType]]Event:: Any event
[[commandSourceType]]CommandSource:: _[clientId, commandId]_ tuple{fn-org306} this event is based on.
This allows a client to know when its command has been processed (either successful or not).
[[freeIdType]]FreeId:: Free node ids

==== How to calculate a CommandSource

`commandSource = base64urlEncode(sha256(concat(clientId, commandId)))`{fn-org306}

1. Concatenate the `clientId` and `commandId`
2. Calculate sha256 hash of that concatenated string
3. Encode the hash with base64url scheme.

Rationale: The originating client for this command does know both the client id and command id.
The same applies for the repository, but NOT other clients.
So the originating client and the repository can calculate the `commandSource`, but not any other client.
Thus, the command -- event correlation is possible for the originating client without revealing any origin information to other clients.

==== How to address references
We refer to references by the tuple of _[parent, reference, index]_.
Rationale: Both reference `target` and `resolveInfo` can be `null`, so they aren't suitable for identifying the reference.
However, `target` and `resolveInfo` MUST NOT both be `null`.


=== Command -- event pairs overview

[plantuml, legend, svg]
----
skinparam legendBackgroundColor #transparent
skinparam legendBorderColor #transparent
skinparam legendEntrySeparator #transparent

legend right
    <b>Legend</b>
    |<#LightSkyBlue>   | added|
    |<#red>| deleted |
    |<#Orange>| moved|
endlegend
----


==== Partitions
[cols="30a,35a,35a"]
|===
|Command / Event / Description |Before |After

|
<<cmd-addPartition>>

<<evnt-partitionAdded>>

Add `newPartition` node as new partition.
|
_nothing_
|
[plantuml, addPartition, svg]
----
hide empty members
hide circles

class newPartition:Person <<Partition>> #LightSkyBlue {
  name: String = "John"
  age: Integer = 23
  alive: Boolean = true
}
----

|
<<cmd-deletePartition>>

<<evnt-partitionDeleted>>

Delete partition `deletedPartition`.
|
[plantuml, deletePartition, svg]
----
hide empty members
hide circles

class "deletedPartition:Person" as deletedPartition <<Partition>> #red {
  name: String = "John"
  age: Integer = 23
  alive: Boolean = true
}

class "leftEye:Eye" as firstLevelChild #red

class "upperEyelid:Eyelid" as secondLevelChild #red

deletedPartition *--> firstLevelChild
firstLevelChild *--> secondLevelChild
----
|
_nothing_

|===

==== Nodes
[cols="30a,35a,35a"]
|===
|Command / Event / Description |Before |After

|
<<cmd-changeConcept>>

<<evnt-conceptChanged>>

Change concept of `node` from `oldConcept` to `newConcept`.
|
[plantuml, changeConcept-before, svg]
----
hide empty members
hide circles

class "node:<color #red>oldConcept</color>"
----
|
[plantuml, changeConcept-after, svg]
----
hide empty members
hide circles

class "node:<color #blue>newConcept</color>"
----

|===

==== Properties

[cols="30a,35a,35a"]
|===
|Command / Event / Description |Before |After

|
<<cmd-addProperty>>

<<evnt-propertyAdded>>

Add `newValue` as value of property `property` to `node`.
|
[plantuml, addProperty-before, svg]
----
hide empty members
hide circles

class "node"
----
|
[plantuml, addProperty-after, svg]
----
hide empty members
hide circles

class "node" {
  <color: #blue>property = newValue</color>
}
----

|
<<cmd-deleteProperty>>

<<evnt-propertyDeleted>>

Delete existing `property` with `oldValue` from `node`.
|
[plantuml, deleteProperty-before, svg]
----
hide empty members
hide circles

class "node" {
  <color #red>property = oldValue</color>
}
----
|
[plantuml, deleteProperty-after, svg]
----
hide empty members
hide circles

class "node"
----

|
<<cmd-changeProperty>>

<<evnt-propertyChanged>>

Change existing `property` of `node` from `oldValue` to `newValue`.
|
[plantuml, changeProperty-before, svg]
----
hide empty members
hide circles

class "node" {
  property = <color #red>oldValue</color>
}
----
|
[plantuml, changeProperty-after, svg]
----
hide empty members
hide circles

class "node" {
  property = <color #blue>newValue</color>
}
----

|===

==== Children

[cols="30a,35a,35a"]
|===
|Command / Event / Description |Before |After

|
<<cmd-addChild>>

<<evnt-childAdded>>

Add new node `newChild` to `parent` in `containment` at `index`.
|
[plantuml, addChild-before, svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "next\nSibling" as nextSibling

parent *--> previousSibling: containment\n[index - 1]
parent *--> nextSibling: containment\n[index]
----
|
[plantuml, addChild-after, svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "newChild:Car" as newChild #LightSkyBlue {
  length:Integer=19
}
class "next\nSibling" as nextSibling

parent *--> previousSibling: containment\n[index - 1]
parent *--> newChild #Blue: containment\n[index]
parent *--> nextSibling: containment\n[index + 1]
----

|
<<cmd-deleteChild>>

<<evnt-childDeleted>>

Delete existing node `deletedChild` from ``parent``'s `containment` at `index`.
|
[plantuml, deleteChild-before, svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "deleted\nChild" as deletedChild #red
class "next\nSibling" as nextSibling

class descendant #red

parent *--> previousSibling: containment\n[index - 1]
parent *--> deletedChild #red: containment\n[index]
parent *--> nextSibling: containment\n[index + 1]

deletedChild *--> descendant #red
----
|
[plantuml, deleteChild-after, svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "next\nSibling" as nextSibling

parent *--> previousSibling: containment\n[index - 1]
parent *--> nextSibling: containment\n[index]
----

|
<<cmd-replaceChild>>

<<evnt-childReplaced>>

Replace existing node `replacedChild` inside ``parent``'s `containment` at `index` with new node `newChild`.
Delete `replacedChild`.
|
[plantuml,replaceChild-before,svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "replaced\nChild" as replacedChild #red
class "next\nSibling" as nextSibling

class descendant #red

parent *--> previousSibling: containment\n[index - 1]
parent *--> replacedChild #red: containment\n[index]
parent *--> nextSibling: containment\n[index + 1]

replacedChild *--> descendant #red
----
|
[plantuml, replaceChild-after, svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "newChild:Car" as newChild #LightSkyBlue {
  length:Integer=19
}
class "next\nSibling" as nextSibling

parent *--> previousSibling: containment\n[index - 1]
parent *--> newChild #Blue: containment\n[index]
parent *--> nextSibling: containment\n[index + 1]
----

|
<<cmd-moveChildFromOtherContainment>>

<<evnt-childMovedFromOtherContainment>>

Move existing node `movedChild` (currently inside ``oldParent``'s `oldContainment` at `oldIndex`)
inside ``newParent``'s `newContainment` at `newIndex`.
|
[plantuml,moveChildFromOtherContainment-before,svg]
----
hide empty members
hide circles

class oldParent

class "old\nPrevious\nSibling" as oldPreviousSibling
class "moved\nChild" as movedChild #Orange
class "old\nNext\nSibling" as oldNextSibling

class descendant #Orange

oldParent *--> oldPreviousSibling: old\nContainment\n[oldIndex - 1]
oldParent *--> movedChild #red: old\nContainment\n[oldIndex]
oldParent *--> oldNextSibling: old\nContainment\n[oldIndex + 1]

movedChild *--> descendant

descendant -[hidden]- newParent

class newParent

class "new\nPrevious\nSibling" as newPreviousSibling
class "new\nNext\nSibling" as newNextSibling

newParent *--> newPreviousSibling: new\nContainment\n[newIndex - 1]
newParent *--> newNextSibling: new\nContainment\n[newIndex]
----
|
[plantuml, moveChildFromOtherContainment-after, svg]
----
hide empty members
hide circles

class oldParent

class "old\nPrevious\nSibling" as oldPreviousSibling
class "old\nNext\nSibling" as oldNextSibling

oldParent *--> oldPreviousSibling: old\nContainment\n[oldIndex - 1]
oldParent *--> oldNextSibling: old\nContainment\n[oldIndex]

oldPreviousSibling -[hidden]- newParent
oldNextSibling -[hidden]- newParent

class newParent

class "new\nPrevious\nSibling" as newPreviousSibling
class "moved\nChild" as movedChild #Orange
class "new\nNext\nSibling" as newNextSibling

class descendant #Orange

newParent *--> newPreviousSibling: new\nContainment\n[newIndex - 1]
newParent *--> movedChild #Blue: new\nContainment\n[newIndex]
newParent *--> newNextSibling: new\nContainment\n[newIndex + 1]

movedChild *--> descendant
----

|
<<cmd-moveChildFromOtherContainmentInSameParent>>

<<evnt-childMovedFromOtherContainmentInSameParent>>

Move existing node `movedChild` (currently inside ``parent``'s `oldContainment` at `oldIndex`)
inside ``parent``'s `newContainment` at `newIndex`.
|
[plantuml,moveChildFromOtherContainmentInSameParent-before,svg]
----
hide empty members
hide circles

class "old\nPrevious\nSibling" as oldPreviousSibling
class descendant #Orange
class "moved\nChild" as movedChild #Orange
class "old\nNext\nSibling" as oldNextSibling

class parent

descendant <--* movedChild

oldPreviousSibling <--* parent: old\nContainment\n[oldIndex - 1]
movedChild <--* parent #red: old\nContainment\n[oldIndex]
oldNextSibling <--* parent: old\nContainment\n[oldIndex + 1]

class "new\nPrevious\nSibling" as newPreviousSibling
class "new\nNext\nSibling" as newNextSibling

parent *--> newPreviousSibling: new\nContainment\n[newIndex - 1]
parent *--> newNextSibling: new\nContainment\n[newIndex]
----
|
[plantuml, moveChildFromOtherContainmentInSameParent-after, svg]
----
hide empty members
hide circles

class "old\nPrevious\nSibling" as oldPreviousSibling
class "old\nNext\nSibling" as oldNextSibling

class parent

oldPreviousSibling <--* parent: old\nContainment\n[oldIndex - 1]
oldNextSibling <--* parent: old\nContainment\n[oldIndex]

class "new\nPrevious\nSibling" as newPreviousSibling
class "moved\nChild" as movedChild #Orange
class "new\nNext\nSibling" as newNextSibling

class descendant #Orange

parent *--> newPreviousSibling: new\nContainment\n[newIndex - 1]
parent *--> movedChild #Blue: new\nContainment\n[newIndex]
parent *--> newNextSibling: new\nContainment\n[newIndex + 1]

movedChild *--> descendant
----

|
<<cmd-moveChildInSameContainment>>

<<evnt-childMovedInSameContainment>>

Move existing node `movedChild` (currently inside ``parent``'s `containment` at `oldIndex`)
inside ``parent``'s `containment` at `newIndex`.
|
[plantuml,moveChildInSameContainment-before,svg]
----
hide empty members
hide circles
left to right direction

class parent

class siblingA
class movedChild #Orange
class siblingB
class siblingC

class descendant #Orange

parent *--> siblingA: containment\n[oldIndex - 1]
parent *--> movedChild: containment\n[<color #red>oldIndex</color>]
parent *--> siblingB: containment\n[oldIndex + 1]
parent *--> siblingC: containment\n[oldIndex + 2]

movedChild *-> descendant

siblingA -[hidden]> movedChild
----
|
[plantuml, moveChildInSameContainment-after, svg]
----
hide empty members
hide circles
left to right direction

class parent

class siblingA
class movedChild #Orange
class siblingB
class siblingC

class descendant #Orange

parent *--> siblingA: containment\n[oldIndex - 1]
parent *--> siblingB: containment\n[oldIndex]
parent *--> movedChild: containment\n[<color #Blue>newIndex</color>]
parent *--> siblingC: containment\n[newIndex + 1]

movedChild *-> descendant

siblingA -[hidden]> siblingB
siblingB -[hidden]> movedChild
----

|
<<cmd-moveChildFromAnnotations>>

<<evnt-childMovedFromAnnotations>>

Move existing node `movedAnnotation` (currently inside ``oldParent``'s annotations at `oldIndex`)
inside ``newParent``'s `newContainment` at `newIndex`.
|
[plantuml,moveChildFromAnnotations-before,svg]
----
hide empty members
hide circles

class oldParent

class "old\nPrevious\nSibling" as oldPreviousSibling
class "moved\nAnnotation" as movedAnnotation #Orange
class "old\nNext\nSibling" as oldNextSibling

class descendant #Orange

oldParent *--> oldPreviousSibling: <<annotations>>\n[oldIndex - 1]
oldParent *--> movedAnnotation #red: <<annotations>>\n[oldIndex]
oldParent *--> oldNextSibling: <<annotations>>\n[oldIndex + 1]

movedAnnotation *--> descendant

descendant -[hidden]- newParent

class newParent

class "new\nPrevious\nSibling" as newPreviousSibling
class "new\nNext\nSibling" as newNextSibling

newParent *--> newPreviousSibling: new\nContainment\n[newIndex - 1]
newParent *--> newNextSibling: new\nContainment\n[newIndex]
----
|
[plantuml,moveChildFromAnnotations-after,svg]
----
hide empty members
hide circles

class oldParent

class "old\nPrevious\nSibling" as oldPreviousSibling
class "old\nNext\nSibling" as oldNextSibling

oldParent *--> oldPreviousSibling: <<annotations>>\n[oldIndex - 1]
oldParent *--> oldNextSibling: <<annotations>>\n[oldIndex]

oldPreviousSibling -[hidden]- newParent
oldNextSibling -[hidden]- newParent

class newParent

class "new\nPrevious\nSibling" as newPreviousSibling
class "moved\nAnnotation" as movedAnnotation #Orange
class "new\nNext\nSibling" as newNextSibling

class descendant #Orange

newParent *--> newPreviousSibling: new\nContainment\n[newIndex - 1]
newParent *--> movedAnnotation #Blue: new\nContainment\n[newIndex]
newParent *--> newNextSibling: new\nContainment\n[newIndex + 1]

movedAnnotation *--> descendant
----

|
<<cmd-moveChildFromAnnotationsInSameParent>>

<<evnt-childMovedFromAnnotationsInSameParent>>

Move existing node `movedAnnotation` (currently inside ``parent``'s annotations at `oldIndex`)
inside ``parent``'s `newContainment` at `newIndex`.
|
[plantuml,moveChildFromAnnotationsInSameParent-before,svg]
----
hide empty members
hide circles

class "old\nPrevious\nSibling" as oldPreviousSibling
class descendant #Orange
class "moved\nAnnotation" as movedAnnotation #Orange
class "old\nNext\nSibling" as oldNextSibling

class parent

descendant <--* movedAnnotation

oldPreviousSibling <--* parent: <<annotations>>\n[oldIndex - 1]
movedAnnotation <--* parent #red: <<annotations>>\n[oldIndex]
oldNextSibling <--* parent: <<annotations>>\n[oldIndex + 1]

class "new\nPrevious\nSibling" as newPreviousSibling
class "new\nNext\nSibling" as newNextSibling

parent *--> newPreviousSibling: new\nContainment\n[newIndex - 1]
parent *--> newNextSibling: new\nContainment\n[newIndex]
----
|
[plantuml,moveChildFromAnnotationsInSameParent-after,svg]
----
hide empty members
hide circles

class "old\nPrevious\nSibling" as oldPreviousSibling
class "old\nNext\nSibling" as oldNextSibling

class parent

oldPreviousSibling <--* parent: <<annotations>>\n[oldIndex - 1]
oldNextSibling <--* parent: <<annotations>>\n[oldIndex]

class "new\nPrevious\nSibling" as newPreviousSibling
class "moved\nAnnotation" as movedAnnotation #Orange
class "new\nNext\nSibling" as newNextSibling

class descendant #Orange

parent *--> newPreviousSibling: new\nContainment\n[newIndex - 1]
parent *--> movedAnnotation #Blue: new\nContainment\n[newIndex]
parent *--> newNextSibling: new\nContainment\n[newIndex + 1]

movedAnnotation *--> descendant
----


|===

==== Annotations

[cols="30a,35a,35a"]
|===
|Command / Event / Description |Before |After

|
<<cmd-addAnnotation>>

<<evnt-annotationAdded>>

Add new node `newAnnotation` to ``parent``'s annotations at `index`.
|
[plantuml, addAnnotation-before, svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "next\nSibling" as nextSibling

parent *--> previousSibling: <<annotations>>\n[index - 1]
parent *--> nextSibling: <<annotations>>\n[index]
----
|
[plantuml,addAnnotation-after,svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "newAnnotation:\nRemark" as newAnnotation #LightSkyBlue {
  text:String="ok"
}
class "next\nSibling" as nextSibling

parent *--> previousSibling: <<annotations>>\n[index - 1]
parent *--> newAnnotation #Blue: <<annotations>>\n[index]
parent *--> nextSibling: <<annotations>>\n[index + 1]
----

|
<<cmd-deleteAnnotation>>

<<evnt-annotationDeleted>>

Delete existing node `deletedAnnotation` from ``parent``'s annotations at `index`.
|
[plantuml,deleteAnnotation-before,svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "deleted\nAnnotation" as deletedAnnotation #red
class "next\nSibling" as nextSibling

class descendant #red

parent *--> previousSibling: <<annotations>>\n[index - 1]
parent *--> deletedAnnotation #red: <<annotations>>\n[index]
parent *--> nextSibling: <<annotations>>\n[index + 1]

deletedAnnotation *--> descendant #red
----
|
[plantuml, deleteAnnotation-after, svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "next\nSibling" as nextSibling

parent *--> previousSibling: <<annotations>>\n[index - 1]
parent *--> nextSibling: <<annotations>>\n[index]
----

|
<<cmd-replaceAnnotation>>

<<evnt-annotationReplaced>>

Replace existing node `replacedAnnotation` inside ``parent``'s annotations at `index` with new node `newAnnotation`.
Delete `replacedAnnotation`.
|
[plantuml,replaceAnnotation-before,svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "replaced\nAnnotation" as replacedAnnotation #red
class "next\nSibling" as nextSibling

class descendant #red

parent *--> previousSibling: <<annotations>>\n[index - 1]
parent *--> replacedAnnotation #red: <<annotations>>\n[index]
parent *--> nextSibling: <<annotations>>\n[index + 1]

replacedAnnotation *--> descendant #red
----
|
[plantuml,replaceAnnotation-after,svg]
----
hide empty members
hide circles

class parent

class "previous\nSibling" as previousSibling
class "newAnnotation:\nRemark" as newAnnotation #LightSkyBlue {
  text:String="ok"
}
class "next\nSibling" as nextSibling

parent *--> previousSibling: <<annotations>>\n[index - 1]
parent *--> newAnnotation #Blue: <<annotations>>\n[index]
parent *--> nextSibling: <<annotations>>\n[index + 1]
----

|
<<cmd-moveAnnotationFromOtherParent>>

<<evnt-annotationMovedFromOtherParent>>

Move existing node `movedAnnotation` (currently inside ``oldParent``'s annotations at `oldIndex`)
inside ``newParent``'s annotations at `newIndex`.
|
[plantuml,moveAnnotationFromOtherParent-before,svg]
----
hide empty members
hide circles

class oldParent

class "old\nPrevious\nSibling" as oldPreviousSibling
class "moved\nAnnotation" as movedAnnotation #Orange
class "old\nNext\nSibling" as oldNextSibling

class descendant #Orange

oldParent *--> oldPreviousSibling: <<annotations>>\n[oldIndex - 1]
oldParent *--> movedAnnotation #red: <<annotations>>\n[oldIndex]
oldParent *--> oldNextSibling: <<annotations>>\n[oldIndex + 1]

movedAnnotation *--> descendant

descendant -[hidden]- newParent

class newParent

class "new\nPrevious\nSibling" as newPreviousSibling
class "new\nNext\nSibling" as newNextSibling

newParent *--> newPreviousSibling: <<annotations>>\n[newIndex - 1]
newParent *--> newNextSibling: <<annotations>>\n[newIndex]
----
|
[plantuml,moveAnnotationFromOtherParent-after,svg]
----
hide empty members
hide circles

class oldParent

class "old\nPrevious\nSibling" as oldPreviousSibling
class "old\nNext\nSibling" as oldNextSibling

oldParent *--> oldPreviousSibling: <<annotations>>\n[oldIndex - 1]
oldParent *--> oldNextSibling: <<annotations>>\n[oldIndex]

oldPreviousSibling -[hidden]- newParent
oldNextSibling -[hidden]- newParent

class newParent

class "new\nPrevious\nSibling" as newPreviousSibling
class "moved\nAnnotation" as movedAnnotation #Orange
class "new\nNext\nSibling" as newNextSibling

class descendant #Orange

newParent *--> newPreviousSibling: <<annotations>>\n[newIndex - 1]
newParent *--> movedAnnotation #Blue: <<annotations>>\n[newIndex]
newParent *--> newNextSibling: <<annotations>>\n[newIndex + 1]

movedAnnotation *--> descendant
----

|
<<cmd-moveAnnotationInSameParent>>

<<evnt-annotationMovedInSameParent>>

Move existing node `movedAnnotation` (currently inside ``parent``'s annotations at `oldIndex`)
inside ``parent``'s annotations at `newIndex`.
|
[plantuml,moveAnnotationInSameParent-before,svg]
----
hide empty members
hide circles
left to right direction

class parent

class siblingA
class "moved\nAnnotation" as movedAnnotation #Orange
class siblingB
class siblingC

class descendant #Orange

parent *--> siblingA: <<annotations>>\n[oldIndex - 1]
parent *--> movedAnnotation: <<annotations>>\n[<color #red>oldIndex</color>]
parent *--> siblingB: <<annotations>>\n[oldIndex + 1]
parent *--> siblingC: <<annotations>>\n[oldIndex + 2]

movedAnnotation *-> descendant

siblingA -[hidden]> movedAnnotation
----
|
[plantuml,moveAnnotationInSameParent-after,svg]
----
hide empty members
hide circles
left to right direction

class parent

class siblingA
class "moved\nAnnotation" as movedAnnotation #Orange
class siblingB
class siblingC

class descendant #Orange

parent *--> siblingA: <<annotations>>\n[oldIndex - 1]
parent *--> siblingB: <<annotations>>\n[oldIndex]
parent *--> movedAnnotation: <<annotations>>\n[<color #Blue>newIndex</color>]
parent *--> siblingC: <<annotations>>\n[newIndex + 1]

movedAnnotation *-> descendant

siblingA -[hidden]> siblingB
siblingB -[hidden]> movedAnnotation
----

|
<<cmd-moveAnnotationFromContainment>>

<<evnt-annotationMovedFromContainment>>

Move existing node `movedChild` (currently inside ``oldParent``'s `oldContainment` at `oldIndex`)
inside ``newParent``'s annotations at `newIndex`.
|
[plantuml,moveAnnotationFromContainment-before,svg]
----
hide empty members
hide circles

class oldParent

class "old\nPrevious\nSibling" as oldPreviousSibling
class "moved\nChild" as movedChild #Orange
class "old\nNext\nSibling" as oldNextSibling

class descendant #Orange

oldParent *--> oldPreviousSibling: old\nContainment\n[oldIndex - 1]
oldParent *--> movedChild #red: old\nContainment\n[oldIndex]
oldParent *--> oldNextSibling: old\nContainment\n[oldIndex + 1]

movedChild *--> descendant

descendant -[hidden]- newParent

class newParent

class "new\nPrevious\nSibling" as newPreviousSibling
class "new\nNext\nSibling" as newNextSibling

newParent *--> newPreviousSibling: <<annotations>>\n[newIndex - 1]
newParent *--> newNextSibling: <<annotations>>\n[newIndex]
----
|
[plantuml, moveAnnotationFromContainment-after, svg]
----
hide empty members
hide circles

class oldParent

class "old\nPrevious\nSibling" as oldPreviousSibling
class "old\nNext\nSibling" as oldNextSibling

oldParent *--> oldPreviousSibling: old\nContainment\n[oldIndex - 1]
oldParent *--> oldNextSibling: old\nContainment\n[oldIndex]

oldPreviousSibling -[hidden]- newParent
oldNextSibling -[hidden]- newParent

class newParent

class "new\nPrevious\nSibling" as newPreviousSibling
class "moved\nChild" as movedChild #Orange
class "new\nNext\nSibling" as newNextSibling

class descendant #Orange

newParent *--> newPreviousSibling: <<annotations>>\n[newIndex - 1]
newParent *--> movedChild #Blue: <<annotations>>\n[newIndex]
newParent *--> newNextSibling: <<annotations>>\n[newIndex + 1]

movedChild *--> descendant
----

|
<<cmd-moveAnnotationFromContainmentInSameParent>>

<<evnt-annotationMovedFromContainmentInSameParent>>

Move existing node `movedChild` (currently inside ``parent``'s `oldContainment` at `oldIndex`)
inside ``parent``'s annotations at `newIndex`.
|
[plantuml,moveAnnotationFromContainmentInSameParent-before,svg]
----
hide empty members
hide circles

class "old\nPrevious\nSibling" as oldPreviousSibling
class descendant #Orange
class "moved\nChild" as movedChild #Orange
class "old\nNext\nSibling" as oldNextSibling

class parent

descendant <--* movedChild

oldPreviousSibling <--* parent: old\nContainment\n[oldIndex - 1]
movedChild <--* parent #red: old\nContainment\n[oldIndex]
oldNextSibling <--* parent: old\nContainment\n[oldIndex + 1]

class "new\nPrevious\nSibling" as newPreviousSibling
class "new\nNext\nSibling" as newNextSibling

parent *--> newPreviousSibling: <<annotations>>\n[newIndex - 1]
parent *--> newNextSibling: <<annotations>>\n[newIndex]
----
|
[plantuml, moveAnnotationFromContainmentInSameParent-after, svg]
----
hide empty members
hide circles

class "old\nPrevious\nSibling" as oldPreviousSibling
class "old\nNext\nSibling" as oldNextSibling

class parent

oldPreviousSibling <--* parent: old\nContainment\n[oldIndex - 1]
oldNextSibling <--* parent: old\nContainment\n[oldIndex]

class "new\nPrevious\nSibling" as newPreviousSibling
class "moved\nChild" as movedChild #Orange
class "new\nNext\nSibling" as newNextSibling

class descendant #Orange

parent *--> newPreviousSibling: <<annotations>>\n[newIndex - 1]
parent *--> movedChild #Blue: <<annotations>>\n[newIndex]
parent *--> newNextSibling: <<annotations>>\n[newIndex + 1]

movedChild *--> descendant
----

|===

=== Commands

==== Lifecycle

[plantuml, commandsLifecycle, svg]
----
hide empty description

[*] -> Created: <i>client</i>\ncreates
Created -> Sent: <i>client</i>\nsends

Sent --> Failed: <i>repository</i>\ninvalid command
Failed -> [*]: <i>client</i>\ndiscards

Sent -> Received: <i>repository</i>\nreceives
Received -> Processed: <i>repository</i> emits event,\n<i>client</i> receives event
Processed --> [*]: <i>client</i>\ndiscards
----

[[cmd-partitions]]
==== Partitions

[[cmd-addPartition]]
===== Add partition
Add `newPartition` node as new partition.

.Parameters
* newPartition: <<nodeType>>
* commandId: <<commandIdType>>

.Errors
* `newPartition` id already exists

.Technical name
`addPartition`

.Related event
<<evnt-partitionAdded>>

[[cmd-deletePartition]]
===== Delete partition
Delete partition `deletedPartition`.

.Parameters
* deletedPartition: <<nodeType>> or <<targetNodeType>> #TODO#
* commandId: <<commandIdType>>

.Errors
* `deletedPartition` does not exist

.Technical name
`deletePartition`

.Related event
<<evnt-partitionDeleted>>

[[cmd-nodes]]
==== Nodes

[[cmd-changeConcept]]
===== Change concept
Change concept of `node` from `oldConcept` to `newConcept`.

.Parameters
* node: <<targetNodeType>>
* newConcept: <<metaPointerType>>
* oldConcept: <<metaPointerType>>
* commandId: <<commandIdType>>

.Errors
* `node` does not exist
* ##?## `node` currently does not have concept `oldConcept`

.Technical name
`changeConcept`

.Related event
<<evnt-conceptChanged>>

[[cmd-properties]]
==== Properties

[[cmd-addProperty]]
===== Add property
Add `newValue` as value of property `property` to `node`.

.Parameters
* node: <<targetNodeType>>
* property: <<metaPointerType>>
* newValue: <<propertyValueType>>
* commandId: <<commandIdType>>

.Errors
* `node` does not exist
* ##?## `property` already set in `node`

.Technical name
`addProperty`

.Related event
<<evnt-propertyAdded>>

[[cmd-deleteProperty]]
===== Delete property
Delete existing `property` with `oldValue` from `node`.

.Parameters
* node: <<targetNodeType>>
* property: <<metaPointerType>>
* oldValue: <<propertyValueType>>
* commandId: <<commandIdType>>

.Errors
* `node` does not exist
* ##?## `property` is not set in `node`
* ##?## `property` currently does not have `oldValue`

.Technical name
`deleteProperty`

.Related event
<<evnt-propertyDeleted>>

[[cmd-changeProperty]]
===== Change property
Change existing `property` of `node` from `oldValue` to `newValue`.

.Parameters
* node: <<targetNodeType>>
* property: <<metaPointerType>>
* newValue: <<propertyValueType>>
* oldValue: <<propertyValueType>>
* commandId: <<commandIdType>>

.Errors
* `node` does not exist
* ##?## `property` is not set in `node`
* ##?## `property` currently does not have `oldValue`


.Technical name
`changeProperty`

.Related event
<<evnt-propertyChanged>>

[[cmd-children]]
==== Children

[[cmd-addChild]]
===== Add child
Add new node `newChild` to `parent` in `containment` at `index`.

.Parameters
* parent: <<targetNodeType>>
* newChild: <<nodeType>>
* containment: <<metaPointerType>>
* index: <<indexType>>
* commandId: <<commandIdType>>

.Events
* `parent` does not exist
* `newChild` id already exists
* `index` is beyond the number of `containment` entries in `parent`

.Technical name
`addChild`

.Related event
<<evnt-childAdded>>

[[cmd-deleteChild]]
===== Delete child
Delete existing node `deletedChild` from ``parent``'s `containment` at `index`.

.Parameters
* deletedChild: <<nodeType>> or <<targetNodeType>> #TODO#
* parent: <<targetNodeType>>
* containment: <<metaPointerType>>
* index: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `deletedChild` does not exist
* `parent` does not exist
* `deletedChild` is not a child of `parent` in `containment`
* ##?## `index` is beyond (the number of `containment` entries in `parent`) - 1
* ##?## `deletedChild` is not the node at ``parent``'s `containment` at `index`.

.Technical name
`deleteChild`

.Related event
<<evnt-childDeleted>>

[[cmd-replaceChild]]
===== Replace child
Replace existing node `replacedChild` inside ``parent``'s `containment` at `index` with new node `newChild`.
Delete `replacedChild`.

.Parameters
* newChild: <<nodeType>>
* replacedChild: <<nodeType>> or <<targetNodeType>> #TODO#
* parent: <<targetNodeType>>
* containment: <<metaPointerType>>
* index: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `newChild` id already exists
* `replacedChild` does not exist
* `parent` does not exist
* `replacedChild` is not a child of `parent` in `containment`
* ##?## `index` is beyond (the number of `containment` entries in `parent`) - 1
* ##?## `replacedChild` is not the node at ``parent``'s `containment` at `index`.

.Technical name
`replaceChild`

.Related event
<<evnt-childReplaced>>

[[cmd-moveChildFromOtherContainment]]
===== Move child from other containment
Move existing node `movedChild` (currently inside ``oldParent``'s `oldContainment` at `oldIndex`)
inside ``newParent``'s `newContainment` at `newIndex`.

.Parameters
* newParent: <<targetNodeType>>
* newContainment: <<metaPointerType>>
* newIndex: <<indexType>>
* movedChild: <<targetNodeType>>
* oldParent: <<targetNodeType>>
* oldContainment: <<metaPointerType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `newParent` does not exist
* `newIndex` is beyond the number of `newContainment` entries in `newParent`
* `movedChild` does not exist
* ##?## `oldParent` does not exist
* ##?## `movedChild` is not a child of `oldParent` in `oldContainment`
* ##?## `oldIndex` is beyond (the number of `oldContainment` entries in `oldParent`) - 1
* ##?## `movedChild` is not the node at ``oldParent``'s `oldContainment` at `oldIndex`.

.Technical name
`moveChildFromOtherContainment`

.Related event
<<evnt-childMovedFromOtherContainment>>

[[cmd-moveChildFromOtherContainmentInSameParent]]
===== Move child from other containment in same parent
Move existing node `movedChild` (currently inside ``parent``'s `oldContainment` at `oldIndex`)
inside ``parent``'s `newContainment` at `newIndex`.

.Parameters
* newContainment: <<metaPointerType>>
* newIndex: <<indexType>>
* movedChild: <<targetNodeType>>
* parent: <<targetNodeType>>
* oldContainment: <<metaPointerType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `newIndex` is beyond the number of `newContainment` entries in `parent`
* `movedChild` does not exist
* `parent` does not exist
* `movedChild` is not a child of `parent` in `oldContainment`
* ##?## `oldIndex` is beyond (the number of `oldContainment` entries in `parent`) - 1
* ##?## `movedChild` is not the node at ``parent``'s `oldContainment` at `oldIndex`.

.Technical name
`moveChildFromOtherContainmentInSameParent`

.Related event
<<evnt-childMovedFromOtherContainmentInSameParent>>

[[cmd-moveChildInSameContainment]]
===== Move child in same containment
Move existing node `movedChild` (currently inside ``parent``'s `containment` at `oldIndex`)
inside ``parent``'s `containment` at `newIndex`.

.Parameters
* newIndex: <<indexType>>
* movedChild: <<targetNodeType>>
* parent: <<targetNodeType>>
* containment: <<metaPointerType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `newIndex` is beyond (the number of `containment` entries in `parent`) - 1
* `movedChild` does not exist
* `parent` does not exist
* ##?## `movedChild` is not a child of `parent` in `containment`
* ##?## `oldIndex` is beyond (the number of `containment` entries in `parent`) - 1
* `newIndex` is same as `oldIndex`
* ##?## `movedChild` is not the node at ``parent``'s `containment` at `oldIndex`.

.Technical name
`moveChildInSameContainment`

.Related event
<<evnt-childMovedInSameContainment>>

[[cmd-moveChildFromAnnotations]]
===== Move child from annotations
Move existing node `movedAnnotation` (currently inside ``oldParent``'s annotations at `oldIndex`)
inside ``newParent``'s `newContainment` at `newIndex`.

.Parameters
* newParent: <<targetNodeType>>
* newContainment: <<metaPointerType>>
* newIndex: <<indexType>>
* movedAnnotation: <<targetNodeType>>
* oldParent: <<targetNodeType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `newParent` does not exist
* `newIndex` is beyond the number of `newContainment` entries in `newParent`
* `movedAnnotation` does not exist
* ##?## `oldParent` does not exist
* ##?## `movedAnnotation` is not an annotation of `oldParent`
* ##?## `oldIndex` is beyond (the number of annotation entries in `oldParent`) - 1
* ##?## `movedAnnotation` is not the node at ``oldParent``'s annotations at `oldIndex`.

.Technical name
`moveChildFromAnnotations`

.Related event
<<evnt-childMovedFromAnnotations>>

[[cmd-moveChildFromAnnotationsInSameParent]]
===== Move child from annotations in same parent
Move existing node `movedAnnotation` (currently inside ``parent``'s annotations at `oldIndex`)
inside ``parent``'s `newContainment` at `newIndex`.

.Parameters
* newContainment: <<metaPointerType>>
* newIndex: <<indexType>>
* movedAnnotation: <<targetNodeType>>
* parent: <<targetNodeType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `newIndex` is beyond the number of `newContainment` entries in `parent`
* `movedAnnotation` does not exist
* `parent` does not exist
* ##?## `movedAnnotation` is not an annotation of `parent`
* ##?## `oldIndex` is beyond (the number of annotation entries in `parent`) - 1
* ##?## `movedAnnotation` is not the node at ``parent``'s annotations at `oldIndex`.

.Technical name
`moveChildFromAnnotationsInSameParent`

.Related event
<<evnt-childMovedFromAnnotationsInSameParent>>

[[cmd-annotations]]
==== Annotations

[[cmd-addAnnotation]]
===== Add annotation
Add new node `newAnnotation` to ``parent``'s annotations at `index`.

.Parameters
* parent: <<targetNodeType>>
* newAnnotation: <<nodeType>>
* index: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `newAnnotation` id already exists
* `index` is beyond the number of annotations of `parent`

.Technical name
`addAnnotation`

.Related event
<<evnt-annotationAdded>>

[[cmd-deleteAnnotation]]
===== Delete annotation
Delete existing node `deletedAnnotation` from ``parent``'s annotations at `index`.

.Parameters
* deletedAnnotation: <<nodeType>> or <<targetNodeType>> #TODO#
* parent: <<targetNodeType>>
* index: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `deletedAnnotation` does not exist
* `parent` does not exist
* `deletedAnnotation` is not an annotation of `parent`
* `index` is beyond (the number of annotations of `parent`) - 1
* ##?## `deletedAnnotation` is not the node at ``parent``'s annotations at `index`.

.Technical name
`deleteAnnotation`

.Related event
<<evnt-annotationDeleted>>

[[cmd-replaceAnnotation]]
===== Replace annotation
Replace existing node `replacedAnnotation` inside ``parent``'s annotations at `index` with new node `newAnnotation`.
Delete `replacedAnnotation`.

.Parameters
* newAnnotation: <<nodeType>>
* replacedAnnotation: <<nodeType>> or <<targetNodeType>> #TODO#
* parent: <<targetNodeType>>
* index: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `newAnnotation` id already exists
* `replacedAnnotation` does not exist
* `parent` does not exist
* `replacedAnnotation` is not an annotation of `parent`
* `index` is beyond (the number of annotations of `parent`) - 1
* ##?## `replacedAnnotation` is not the node at ``parent``'s annotations at `index`.

.Technical name
`replaceAnnotation`

.Related event
<<evnt-annotationReplaced>>

[[cmd-moveAnnotationFromOtherParent]]
===== Move annotation from other parent
Move existing node `movedAnnotation` (currently inside ``oldParent``'s annotations at `oldIndex`)
inside ``newParent``'s annotations at `newIndex`.

.Parameters
* newParent: <<targetNodeType>>
* newIndex: <<indexType>>
* movedAnnotation: <<targetNodeType>>
* oldParent: <<targetNodeType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `newParent` does not exist
* `index` is beyond the number of annotations of `newParent`
* `movedAnnotation` does not exist
* `oldParent` does not exist
* `movedAnnotation` is not an annotation of `oldParent`
* `oldIndex` is beyond (the number of annotations of `oldParent`) - 1
* ##?## `movedAnnotation` is not the node at ``oldParent``'s annotations at `oldIndex`.

.Technical name
`moveAnnotationFromOtherParent`

.Related event
<<evnt-annotationMovedFromOtherParent>>


[[cmd-moveAnnotationInSameParent]]
===== Move annotation in same parent
Move existing node `movedAnnotation` (currently inside ``parent``'s annotations at `oldIndex`)
inside ``parent``'s annotations at `newIndex`.

.Parameters
* newIndex: <<indexType>>
* movedAnnotation: <<targetNodeType>>
* parent: <<targetNodeType>>
* oldIndex: <<targetNodeType>>
* commandId: <<commandIdType>>

.Errors
* `newIndex` is beyond (the number of annotations of `parent`) - 1
* `movedAnnotation` does not exist
* `parent` does not exist
* `movedAnnotation` is not an annotation of `parent`
* `oldIndex` is beyond (the number of annotations of `parent`) - 1
* ##?## `movedAnnotation` is not the node at ``parent``'s annotations at `oldIndex`.

.Technical name
`moveAnnotationInSameParent`

.Related event
<<evnt-annotationMovedInSameParent>>

[[cmd-moveAnnotationFromContainment]]
===== Move annotation from containment
Move existing node `movedChild` (currently inside ``oldParent``'s `oldContainment` at `oldIndex`)
inside ``newParent``'s annotations at `newIndex`.

.Parameters
* newParent: <<targetNodeType>>
* newIndex: <<indexType>>
* movedChild: <<targetNodeType>>
* oldParent: <<targetNodeType>>
* oldContainment: <<metaPointerType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `newParent` does not exist
* `newIndex` is beyond the number of annotation entries in `newParent`
* `movedChild` does not exist
* ##?## `oldParent` does not exist
* ##?## `movedChild` is not a child of `oldParent` in `oldContainment`
* ##?## `oldIndex` is beyond (the number of `oldContainment` entries in `oldParent`) - 1
* ##?## `movedChild` is not the node at ``oldParent``'s `oldContainment` at `oldIndex`.

.Technical name
`moveAnnotationFromContainment`

.Related event
<<evnt-annotationMovedFromContainment>>

[[cmd-moveAnnotationFromContainmentInSameParent]]
===== Move annotation from containment in same parent
Move existing node `movedChild` (currently inside ``parent``'s `oldContainment` at `oldIndex`)
inside ``parent``'s annotations at `newIndex`.

.Parameters
* newContainment: <<metaPointerType>>
* newIndex: <<indexType>>
* movedChild: <<targetNodeType>>
* parent: <<targetNodeType>>
* oldContainment: <<metaPointerType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Errors
* `newIndex` is beyond the number of annotation entries in `parent`
* `movedChild` does not exist
* `parent` does not exist
* ##?## `movedChild` is not a child of `parent` in `oldContainment`
* ##?## `oldIndex` is beyond (the number of `oldContainment` entries in `parent`) - 1
* ##?## `movedChild` is not the node at ``parent``'s `oldContainment` at `oldIndex`.

.Technical name
`moveAnnotationFromContainmentInSameParent`

.Related event
<<evnt-annotationMovedFromContainmentInSameParent>>

[[cmd-references]]
==== References

[[cmd-addReference]]
===== Add reference
Add `newTarget` / `newResolveInfo` to ``parent``'s `reference` at `index`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newTarget: <<targetNodeType>>?
* newResolveInfo: <<resolveInfoType>>?
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond the number of `reference` entries of `parent`
* `newTarget` is `null` and `newResolveInfo` is `null`

.Technical name
`addReference`

.Related event
<<evnt-referenceAdded>>

[[cmd-deleteReference]]
===== Delete reference
Delete existing `deletedTarget`/`deletedResolveInfo` from ``parent``'s `reference` at `index`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* deletedTarget: <<targetNodeType>>?
* deletedResolveInfo: <<resolveInfoType>>?
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `deletedTarget` is `null` and `deletedResolveInfo` is `null`
* ##?## `deletedTarget` is not the target at ``parent``'s `reference` at `index`.
* ##?## `deletedResolveInfo` is not the resolveInfo at ``parent``'s `reference` at `index`.

.Technical name
`deleteReference`

.Related event
<<evnt-referenceDeleted>>

[[cmd-changeReference]]
===== Change reference
Replace existing `replacedTarget`/`replacedResolveInfo`  inside ``parent``'s `reference` at `index` with `newTarget`/`newResolveInfo`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newTarget: <<targetNodeType>>?
* newResolveInfo: <<targetNodeType>>?
* replacedTarget: <<targetNodeType>>?
* replacedResolveInfo: <<resolveInfoType>>?
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `newTarget` is `null` and `newResolveInfo` is `null`
* `replacedTarget` is `null` and `replacedResolveInfo` is `null`
* ##?## `replacedTarget` is not the target at ``parent``'s `reference` at `index`.
* ##?## `replacedResolveInfo` is not the resolveInfo at ``parent``'s `reference` at `index`.

.Technical name
`changeReference`

.Related event
<<evnt-referenceChanged>>

[[cmd-moveEntryFromOtherReference]]
===== Move entry from other reference
Move existing `target`/`resolveInfo` (currently inside ``oldParent``'s `oldReference` at `oldIndex`)
to ``newParent``'s `newReference` at `newIndex`.

.Parameters
* newParent: <<targetNodeType>>
* newReference: <<metaPointerType>>
* newIndex: <<indexType>>
* oldParent: <<targetNodeType>>
* oldReference: <<metaPointerType>>
* oldIndex: <<indexType>>
* target: <<targetNodeType>>?
* resolveInfo: <<resolveInfoType>>?
* commandId: <<commandIdType>>

.Errors
* `newParent` does not exist
* `newIndex` is beyond (the number of `newReference` entries of `newParent`)
* `oldIndex` is beyond (the number of `oldReference` entries of `oldParent`) - 1
* `target` is `null` and `resolveInfo` is `null`
* ##?## `target` is not the target at ``oldParent``'s `oldReference` at `oldIndex`.
* ##?## `resolveInfo` is not the resolveInfo at ``oldParent``'s `oldReference` at `oldIndex`.

.Technical name
`moveEntryFromOtherReference`

.Related event
<<evnt-entryMovedFromOtherReference>>

[[cmd-moveEntryFromOtherReferenceInSameParent]]
===== Move entry from other reference in same parent
Move existing `target`/`resolveInfo` (currently inside ``parent``'s `oldReference` at `oldIndex`)
to ``parent``'s `newReference` at `newIndex`.

.Parameters
* parent: <<targetNodeType>>
* newReference: <<metaPointerType>>
* newIndex: <<indexType>>
* oldReference: <<metaPointerType>>
* oldIndex: <<indexType>>
* target: <<targetNodeType>>?
* resolveInfo: <<resolveInfoType>>?
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `newIndex` is beyond (the number of `newReference` entries of `parent`)
* `oldIndex` is beyond (the number of `oldReference` entries of `parent`) - 1
* `target` is `null` and `resolveInfo` is `null`
* ##?## `target` is not the target at ``parent``'s `oldReference` at `oldIndex`.
* ##?## `resolveInfo` is not the resolveInfo at ``parent``'s `oldReference` at `oldIndex`.

.Technical name
`moveEntryFromOtherReferenceInSameParent`

.Related event
<<evnt-entryMovedFromOtherReferenceInSameParent>>

[[cmd-moveEntryInSameReference]]
===== Move entry in same reference
Move existing `target`/`resolveInfo` (currently inside ``parent``'s `reference` at `oldIndex`)
inside ``parent``'s `reference` at `newIndex`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* oldIndex: <<indexType>>
* newIndex: <<indexType>>
* target: <<targetNodeType>>?
* resolveInfo: <<resolveInfoType>>?
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `newIndex` is beyond (the number of `reference` entries of `parent`) - 1
* `oldIndex` is beyond (the number of `reference` entries of `parent`) - 1
* `target` is `null` and `resolveInfo` is `null`
* ##?## `target` is not the target at ``parent``'s `reference` at `oldIndex`.
* ##?## `resolveInfo` is not the resolveInfo at ``parent``'s `reference` at `oldIndex`.

.Technical name
`moveEntryInSameReference`

.Related event
<<evnt-entryMovedInSameReference>>

[[cmd-addReferenceResolveInfo]]
===== Add reference ResolveInfo
Add `newResolveInfo` as ResolveInfo to existing entry inside ``parent``'s `reference` at `index` with `target`.

****
`target` MUST NOT be `null` as we can only add ResolveInfo if ResolveInfo is `null`, and at least one of target and ResolveInfo MUST always be non-`null`.
****

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newResolveInfo: <<resolveInfoType>>
* target: <<targetNodeType>>
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `newResolveInfo` is `null`
* ##?## resolveInfo already set in ``parent``'s `reference` at `index`.

.Technical name
`addReferenceResolveInfo`

.Related event
<<evnt-referenceResolveInfoAdded>>

[[cmd-deleteReferenceResolveInfo]]
===== Delete reference ResolveInfo
Delete existing `deletedResolveInfo` as ResolveInfo from existing entry inside ``parent``'s `reference` at `index` with `target`.

****
`target` MUST NOT be `null` as we're about to remove ResolveInfo, and at least one of target and ResolveInfo MUST always be non-`null`.
****

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* target: <<targetNodeType>>
* deletedResolveInfo: <<resolveInfoType>>
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `deletedResolveInfo` is `null`
* `target` is `null`
* ##?## resolveInfo is not set in ``parent``'s `reference` at `index`.
* ##?## resolveInfo currently is not `deletedResolveInfo` in ``parent``'s `reference` at `index`.

.Technical name
`deleteReferenceResolveInfo`

.Related event
<<evnt-referenceResolveInfoDeleted>>

[[cmd-changeReferenceResolveInfo]]
===== Change reference ResolveInfo
Change ResolveInfo of existing entry inside ``parent``'s `reference` at `index` from `oldResolveInfo` to `newResolveInfo`.

****
`target` MAY be `null` as we can only change ResolveInfo if both `oldResolveInfo` and `newResolveInfo` is non-`null`.
****

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newResolveInfo: <<resolveInfoType>>
* target: <<targetNodeType>>?
* oldResolveInfo: <<resolveInfoType>>
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `newResolveInfo` is `null`
* `oldResolveInfo` is `null`
* ##?## resolveInfo is not set in ``parent``'s `reference` at `index`
* ##?## resolveInfo currently is not `oldResolveInfo` in ``parent``'s `reference` at `index`

.Technical name
`changeReferenceResolveInfo`

.Related event
<<evnt-referenceResolveInfoChanged>>

[[cmd-addReferenceTarget]]
===== Add reference target
Add `newTarget` as target to existing entry inside ``parent``'s `reference` at `index` with `resolveInfo`.

****
`resolveInfo` MUST NOT be `null` as we can only add target if target is `null`, and at least one of target and ResolveInfo MUST always be non-`null`.
****

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newTarget: <<targetNodeType>>
* resolveInfo: <<resolveInfoType>>
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `newTarget` is `null`
* ##?## target already set in ``parent``'s `reference` at `index`.

.Technical name
`addReferenceTarget`

.Related event
<<evnt-referenceTargetAdded>>

[[cmd-deleteReferenceTarget]]
===== Delete reference target
Delete existing `deletedTarget` as target from existing entry inside ``parent``'s `reference` at `index` with `resolveInfo`.

****
`resolveInfo` MUST NOT be `null` as we're about to remove target, and at least one of target and ResolveInfo MUST always be non-`null`.
****

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* resolveInfo: <<resolveInfoType>>
* deletedTarget: <<targetNodeType>>
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `deletedTarget` is `null`
* ##?## target is not set in ``parent``'s `reference` at `index`.
* ##?## target currently is not `deletedTarget` in ``parent``'s `reference` at `index`.

.Technical name
`deleteReferenceTarget`

.Related event
<<evnt-referenceTargetDeleted>>

[[cmd-changeReferenceTarget]]
===== Change reference target
Change target of existing entry inside ``parent``'s `reference` at `index` with `resolveInfo` from `oldTarget` to `newTarget`.

****
`resolveInfo` MAY be `null` as we can only change target if both `oldTarget` and `newTarget` is non-`null`.
****

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newTarget: <<targetNodeType>>
* resolveInfo: <<resolveInfoType>>?
* oldTarget: <<targetNodeType>>
* commandId: <<commandIdType>>

.Errors
* `parent` does not exist
* `index` is beyond (the number of `reference` entries of `parent`) - 1
* `newTarget` is `null`
* `oldTarget` is `null`
* ##?## target is not set in ``parent``'s `reference` at `index`
* ##?## target currently is not `oldTarget` in ``parent``'s `reference` at `index`

.Technical name
`changeReferenceTarget`

.Related event
<<evnt-referenceTargetChanged>>

[[cmd-composite-section]]
==== Composite

[[cmd-composite]]
===== composite
Groups several commands into a logical group.
The parts are ordered.

Command groups don't guarantee anything; the repository MAY take the group as a hint to resolve conflicts in a different manner.

.Parameters
* parts: <<commandType>>[]
* commandId: <<commandIdType>>

.Errors
* accumulation of all errors of `parts`

.Technical name
`composite`

.Related event
<<evnt-composite>>

=== Queries

[[cmd-subscription]]
==== Subscription

[[qry-subscribePartitions]]
===== Subscribe to partition changes
This client wants to receive events on newly created (`creation` is true) or deleted (`deletion` is true) partitions.

.Request parameters
* creation: `boolean`
* deletion: `boolean`
* partitions: `boolean`
* queryId: <<queryIdType>>

.Response parameters
* queryId: <<queryIdType>>

.Errors
_none_

.Technical name
`subscribePartitions`

[[qry-subscribePartition]]
===== Subscribe to partition
This client wants to receive events on any changes to `partition` or any of its descendants.

.Request parameters
* partition: <<targetNodeType>>
* queryId: <<queryIdType>>

.Response parameters
* contents: <<chunkType>>
* queryId: <<queryIdType>>

.Errors
* already subscribed to `partition`

.Technical name
`subscribePartition`

[[cmd-unsubscribePartition]]
===== Unsubscribe from partition
This client does not want to receive events on any changes to `partition` or any of its descendants anymore.

.Request parameters
* partition: <<targetNodeType>>
* queryId: <<queryIdType>>

.Response parameters
* queryId: <<queryIdType>>

.Errors
* not subscribed to `partition`

.Technical name
`unsubscribePartition`

[[cmd-misc]]
==== Miscellaneous

[[cmd-getAvailableIds]]
===== Get available ids
Request `count` number of unused <<{m3}.adoc#identifiers, valid ids>>.

`ids` might contain less or equal number of ids than `count`.

.Request parameters
* count: `integer`
* queryId: <<queryIdType>>

.Response parameters
* ids: <<freeIdType>>[]
* queryId: <<queryIdType>>

.Errors
_none_

.Technical name
`getAvailableIds`


=== Events

[[evnt-partitions]]
==== Partitions

[[evnt-partitionAdded]]
===== Partition added
Partition `newPartition` has been added to the repository.

This client is now subscribed to any changes to `newPartition` or any of its descendants.

.Parameters
* newPartition: <<nodeType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`partitionAdded`

.Related command
<<cmd-addPartition>>

[[evnt-partitionDeleted]]
===== Partition deleted
Partition `deletedPartition`, and all its descendants, have been deleted from the repository.

This client is now unsubscribed from any changes to `deletedPartition` or any of its descendants.

.Parameters
* deletedPartition: <<nodeType>> or <<targetNodeType>> #TODO#
* originCommands: <<commandSourceType>>[]

.Technical name
`partitionDeleted`

.Related command
<<cmd-deletePartition>>

[[evnt-nodes]]
==== Nodes

[[evnt-conceptChanged]]
===== Concept changed
Concept of `node` has been changed from `oldConcept` to `newConcept`.

.Parameters
* node: <<targetNodeType>>
* newConcept: <<metaPointerType>>
* oldConcept: <<metaPointerType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`conceptChanged`

.Related command
<<cmd-changeConcept>>

[[evnt-properties]]
==== Properties

[[evnt-propertyAdded]]
===== Property added
`property` of `node` has been set to `newValue`.

.Parameters
* node: <<targetNodeType>>
* property: <<metaPointerType>>
* newValue: <<propertyValueType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`propertyAdded`

.Related command
<<cmd-addProperty>>

[[evnt-propertyDeleted]]
===== Property deleted
Existing `property` of `node` with `oldValue` has been deleted.

.Parameters
* node: <<targetNodeType>>
* property: <<metaPointerType>>
* oldValue: <<propertyValueType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`propertyDeleted`

.Related command
<<cmd-deleteProperty>>

[[evnt-propertyChanged]]
===== Property changed
Existing `property` of `node` has been changed from `oldValue` to `newValue`.

.Parameters
* node: <<targetNodeType>>
* property: <<metaPointerType>>
* newValue: <<propertyValueType>>
* oldValue: <<propertyValueType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`propertyChanged`

.Related command
<<cmd-changeProperty>>

[[evnt-children]]
==== Children

[[evnt-childAdded]]
===== Child added
New node `newChild` has been added to ``parent``'s  `containment` at `index`.
All other children inside ``parent``'s `containment` with index >= `index` have been moved to next higher index.

.Parameters
* parent: <<targetNodeType>>
* newChild: <<nodeType>>
* containment: <<metaPointerType>>
* index: <<indexType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`childAdded`

.Related command
<<cmd-addChild>>

[[evnt-childDeleted]]
===== Child deleted
Existing node `deletedChild`, and all its descendants, have been deleted from ``parent``'s `containment` at `index`.
All other children inside ``parent``'s `containment` with index > `index` have been moved to next lower index.

.Parameters
* deletedChild: <<nodeType>> or <<targetNodeType>> #TODO#
* parent: <<targetNodeType>>
* containment: <<metaPointerType>>
* index: <<indexType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`childDeleted`

.Related command
<<cmd-deleteChild>>

[[evnt-childReplaced]]
===== Child replaced
Existing node `replacedChild` inside ``parent``'s `containment` at `index` has been replaced with new node `newChild`.
`replacedChild`, and all its descendants, have been deleted.

.Parameters
* newChild: <<nodeType>>
* replacedChild: <<nodeType>> or <<targetNodeType>> #TODO#
* parent: <<targetNodeType>>
* containment: <<metaPointerType>>
* index: <<indexType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`childReplaced`

.Related command
<<cmd-replaceChild>>

[[evnt-childMovedFromOtherContainment]]
===== Child moved from other containment
Existing node `movedChild` (previously inside ``oldParent``'s `oldContainment` at `oldIndex`) has been moved
inside ``newParent``'s `newContainment` at `newIndex`.

All other children inside ``oldParent``'s `oldContainment` with index > `oldIndex` have been moved to next lower index.

All other children inside ``newParent``'s `newContainment` with index >= `newIndex` have been moved to next higher index.

.Parameters
* newParent: <<targetNodeType>>
* newContainment: <<metaPointerType>>
* newIndex: <<indexType>>
* movedChild: <<targetNodeType>>
* oldParent: <<targetNodeType>>
* oldContainment: <<metaPointerType>>
* oldIndex: <<indexType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`childMovedFromOtherContainment`

.Related command
<<cmd-moveChildFromOtherContainment>>

[[evnt-childMovedFromOtherContainmentInSameParent]]
===== Child moved from other containment in same parent
Existing node `movedChild` (previously inside ``parent``'s `oldContainment` at `oldIndex`) has been moved
inside ``parent``'s `newContainment` at `newIndex`.

All other children inside ``parent``'s `oldContainment` with index > `oldIndex` have been moved to next lower index.

All other children inside ``parent``'s `newContainment` with index >= `newIndex` have been moved to next higher index.

.Parameters
* newContainment: <<metaPointerType>>
* newIndex: <<indexType>>
* movedChild: <<targetNodeType>>
* parent: <<targetNodeType>>
* oldContainment: <<metaPointerType>>
* oldIndex: <<indexType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`childMovedFromOtherContainmentInSameParent`

.Related command
<<cmd-moveChildFromOtherContainmentInSameParent>>

[[evnt-childMovedInSameContainment]]
===== Child moved in same containment
Existing node `movedChild` (previously inside ``parent``'s `containment` at `oldIndex`) has been moved
inside ``parent``'s `containment` at `newIndex`.

If `oldIndex` < `newIndex`: All other children inside ``parent``'s `containment` with previous index > `oldIndex` and previous index <= `newIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=5`: `A[0] B[1] C[2] _D[3] E[4]_ *X[5]* F[6]`

If `oldIndex` > `newIndex`: All other children inside ``parent``'s `containment` with previous index >= `newIndex` and previous index < `oldIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=1`: `A[0] *X[1]* _B[2] C[3]_ D[4] E[5] F[6]`

`oldIndex` MUST NOT be equal to `newIndex`.

.Parameters
* newIndex: <<indexType>>
* movedChild: <<targetNodeType>>
* parent: <<targetNodeType>>
* containment: <<metaPointerType>>
* oldIndex: <<indexType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`childMovedInSameContainment`

.Related command
<<cmd-moveChildInSameContainment>>

[[evnt-childMovedFromAnnotations]]
===== Child moved from annotations
Existing node `movedAnnotation` (previously inside ``oldParent``'s annotations at `oldIndex`) has been moved
inside ``newParent``'s `newContainment` at `newIndex`.

All other annotations inside ``oldParent``'s `annotations` with index > `oldIndex` have been moved to next lower index.

All other children inside ``newParent``'s `newContainment` with index >= `newIndex` have been moved to next higher index.

.Parameters
* newParent: <<targetNodeType>>
* newContainment: <<metaPointerType>>
* newIndex: <<indexType>>
* movedAnnotation: <<targetNodeType>>
* oldParent: <<targetNodeType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Technical name
`childMovedFromAnnotations`

.Related command
<<cmd-moveChildFromAnnotations>>

[[evnt-childMovedFromAnnotationsInSameParent]]
===== Child moved from annotations in same parent
Existing node `movedAnnotation` (previously inside ``parent``'s annotations at `oldIndex`) has been moved
inside ``parent``'s `newContainment` at `newIndex`.

All other annotations inside ``parent``'s `annotations` with index > `oldIndex` have been moved to next lower index.

All other children inside ``parent``'s `newContainment` with index >= `newIndex` have been moved to next higher index.

.Parameters
* newContainment: <<metaPointerType>>
* newIndex: <<indexType>>
* movedAnnotation: <<targetNodeType>>
* parent: <<targetNodeType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Technical name
`childMovedFromAnnotationsInSameParent`

.Related command
<<cmd-moveChildFromAnnotationsInSameParent>>

[[evnt-annotations]]
==== Annotations

[[evnt-annotationAdded]]
===== Annotation added
New node `newAnnotation` has been added to ``parent``'s annotations at `index`.
All other annotations inside ``parent``'s annotations with index >= `index` have been moved to next higher index.

.Parameters
* parent: <<targetNodeType>>
* newAnnotation: <<nodeType>>
* index: <<indexType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`annotationAdded`

.Related command
<<cmd-addAnnotation>>

[[evnt-annotationDeleted]]
===== Annotation deleted
Existing node `deletedAnnotation`, and all its descendants, have been deleted from ``parent``'s annotations at `index`.
All other annotations inside ``parent``'s annotations with index > `index` have been moved to next lower index.

.Parameters
* deletedAnnotation: <<nodeType>> or <<targetNodeType>> #TODO#
* parent: <<targetNodeType>>
* index: <<indexType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`annotationDeleted`

.Related command
<<cmd-deleteAnnotation>>

[[evnt-annotationReplaced]]
===== Annotation replaced
Existing node `replacedAnnotation` inside ``parent``'s annotations at `index` has been replaced with new node `newAnnotation`.
`replacedAnnotation`, and all its descendants, have been deleted.

.Parameters
* newAnnotation: <<nodeType>>
* replacedAnnotation: <<nodeType>> or <<targetNodeType>> #TODO#
* parent: <<targetNodeType>>
* index: <<indexType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`annotationReplaced`

.Related command
<<cmd-replaceAnnotation>>

[[evnt-annotationMovedFromOtherParent]]
===== Annotation moved from other parent
Existing node `movedAnnotation` (previously inside ``oldParent``'s annotations at `oldIndex`) has been moved
inside ``newParent``'s annotations at `newIndex`.

All other annotations inside ``oldParent``'s annotations with index > `oldIndex` have been moved to next lower index.

All other annotations inside ``newParent``'s annotations with index >= `newIndex` have been moved to next higher index.

.Parameters
* newParent: <<targetNodeType>>
* newIndex: <<indexType>>
* movedAnnotation: <<targetNodeType>>
* oldParent: <<targetNodeType>>
* oldIndex: <<indexType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`annotationMovedFromOtherParent`

.Related command
<<cmd-moveAnnotationFromOtherParent>>

[[evnt-annotationMovedInSameParent]]
===== Annotation moved in same parent
Existing node `movedAnnotation` (previously inside ``parent``'s annotations at `oldIndex`) has been moved
inside ``parent``'s annotations at `newIndex`.

If `oldIndex` < `newIndex`: All other annotations inside ``parent``'s annotations with previous index > `oldIndex` and previous index <= `newIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=5`: `A[0] B[1] C[2] _D[3] E[4]_ *X[5]* F[6]`

If `oldIndex` > `newIndex`: All other annotations inside ``parent``'s annotations with previous index >= `newIndex` and previous index < `oldIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=1`: `A[0] *X[1]* _B[2] C[3]_ D[4] E[5] F[6]`

`oldIndex` MUST NOT be equal to `newIndex`.

.Parameters
* newIndex: <<indexType>>
* movedAnnotation: <<targetNodeType>>
* parent: <<targetNodeType>>
* oldIndex: <<targetNodeType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`annotationMovedInSameParent`

.Related command
<<cmd-moveAnnotationInSameParent>>

[[evnt-annotationMovedFromContainment]]
===== Annotation moved from containment
Existing node `movedChild` (previously inside ``oldParent``'s `oldContainment` at `oldIndex`) has been moved
inside ``newParent``'s annotations at `newIndex`.

All other children inside ``oldParent``'s `oldContainment` with index > `oldIndex` have been moved to next lower index.

All other annotations inside ``newParent``'s annotations with index >= `newIndex` have been moved to next higher index.

.Parameters
* newParent: <<targetNodeType>>
* newIndex: <<indexType>>
* movedChild: <<targetNodeType>>
* oldParent: <<targetNodeType>>
* oldContainment: <<metaPointerType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Technical name
`annotationMovedFromContainment`

.Related command
<<cmd-moveAnnotationFromContainment>>

[[evnt-annotationMovedFromContainmentInSameParent]]
===== Annotation moved from containment in same parent
Existing node `movedChild` (previously inside ``parent``'s `oldContainment` at `oldIndex`) has been moved
inside ``parent``'s annotations at `newIndex`.

All other children inside ``parent``'s `oldContainment` with index > `oldIndex` have been moved to next lower index.

All other annotations inside ``parent``'s annotations with index >= `newIndex` have been moved to next higher index.

.Parameters
* newContainment: <<metaPointerType>>
* newIndex: <<indexType>>
* movedChild: <<targetNodeType>>
* parent: <<targetNodeType>>
* oldContainment: <<metaPointerType>>
* oldIndex: <<indexType>>
* commandId: <<commandIdType>>

.Technical name
`annotationMovedFromContainmentInSameParent`

.Related command
<<cmd-moveAnnotationFromContainmentInSameParent>>

[[evnt-references]]
==== References

[[evnt-referenceAdded]]
===== Reference added
Reference with `newTarget`/`newResolveInfo` has been added to ``parent``'s `reference` at `index`.
All other entries inside ``parent``'s `reference` with index >= `index` have been moved to next higher index.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newTarget: <<targetNodeType>>?
* newResolveInfo: <<resolveInfoType>>?
* originCommands: <<commandSourceType>>[]

.Technical name
`referenceAdded`

.Related command
<<cmd-addReference>>

[[evnt-referenceDeleted]]
===== Reference deleted
Existing reference with `deletedTarget`/`deletedResolveInfo` has been deleted from ``parent``'s `reference` at `index`.
All other entries inside ``parent``'s `reference` with index > `index` have been moved to next lower index.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* deletedTarget: <<targetNodeType>>
* deletedResolveInfo: <<resolveInfoType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`referenceDeleted`

.Related command
<<cmd-deleteReference>>

[[evnt-referenceChanged]]
===== Reference changed
Existing reference with `replacedTarget`/`replacedResolveInfo` inside ``parent``'s annotations at `index` has been replaced with `newTarget`/`newResolveInfo`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newTarget: <<targetNodeType>>?
* newResolveInfo: <<targetNodeType>>?
* replacedTarget: <<targetNodeType>>
* replacedResolveInfo: <<resolveInfoType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`referenceChanged`

.Related command
<<cmd-changeReference>>

[[evnt-entryMovedFromOtherReference]]
===== Entry moved from other reference
Existing reference `target`/`resolveInfo` (previously inside ``oldParent``'s `oldReference` at `oldIndex`) has been moved
to ``newParent``'s `newReference` at `newIndex`.

All other entries inside ``oldParent``'s `oldReference` with index > `oldIndex` have been moved to next lower index.

All other entries inside ``newParent``'s `newReference` with index >= `newIndex` have been moved to next higher index.

.Parameters
* newParent: <<targetNodeType>>
* newReference: <<metaPointerType>>
* newIndex: <<indexType>>
* oldParent: <<targetNodeType>>
* oldReference: <<metaPointerType>>
* oldIndex: <<indexType>>
* target: <<targetNodeType>>
* resolveInfo: <<resolveInfoType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`entryMovedFromOtherReference`

.Related command
<<cmd-moveEntryFromOtherReference>>

[[evnt-entryMovedFromOtherReferenceInSameParent]]
===== Entry moved from other reference in same parent
Existing reference `target`/`resolveInfo` (previously inside ``parent``'s `oldReference` at `oldIndex`) has been moved
to ``parent``'s `newReference` at `newIndex`.

All other entries inside ``parent``'s `oldReference` with index > `oldIndex` have been moved to next lower index.

All other entries inside ``parent``'s `newReference` with index >= `newIndex` have been moved to next higher index.

.Parameters
* parent: <<targetNodeType>>
* newReference: <<metaPointerType>>
* newIndex: <<indexType>>
* oldReference: <<metaPointerType>>
* oldIndex: <<indexType>>
* target: <<targetNodeType>>
* resolveInfo: <<resolveInfoType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`entryMovedFromOtherReferenceInSameParent`

.Related command
<<cmd-moveEntryFromOtherReferenceInSameParent>>

[[evnt-entryMovedInSameReference]]
===== Entry moved in same reference
Existing reference `target`/`resolveInfo` (previously inside ``parent``'s `reference` at `oldIndex`) has been moved
to ``parent``'s `reference` at `newIndex`.

If `oldIndex` < `newIndex`: All other entries inside ``parent``'s `reference` with previous index > `oldIndex` and previous index <= `newIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=5`: `A[0] B[1] C[2] _D[3] E[4]_ *X[5]* F[6]`

If `oldIndex` > `newIndex`: All other entries inside ``parent``'s `reference` with previous index >= `newIndex` and previous index < `oldIndex` have been moved to next lower index.
Example: +
`oldIndex=3`: `A[0] B[1] C[2] *X[3]* D[4] E[5] F[6]` -> +
`newIndex=1`: `A[0] *X[1]* _B[2] C[3]_ D[4] E[5] F[6]`

`oldIndex` MUST NOT be equal to `newIndex`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* oldIndex: <<indexType>>
* newIndex: <<indexType>>
* target: <<targetNodeType>>
* resolveInfo: <<resolveInfoType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`entryMovedInSameReference`

.Related command
<<cmd-moveEntryInSameReference>>

[[evnt-referenceResolveInfoAdded]]
===== Reference ResolveInfo added
`newResolveInfo` has been added as ResolveInfo to existing entry inside ``parent``'s `reference` at `index` with `target`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newResolveInfo: <<resolveInfoType>>
* target: <<targetNodeType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`referenceResolveInfoAdded`

.Related command
<<cmd-addReferenceResolveInfo>>

[[evnt-referenceResolveInfoDeleted]]
===== Reference ResolveInfo deleted
ResolveInfo `deletedResolveInfo` has been deleted from existing entry inside ``parent``'s `reference` at `index` with `target`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* target: <<targetNodeType>>
* deletedResolveInfo: <<resolveInfoType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`referenceResolveInfoDeleted`

.Related command
<<cmd-deleteReferenceResolveInfo>>

[[evnt-referenceResolveInfoChanged]]
===== Reference ResolveInfo changed
ResolveInfo of existing entry inside ``parent``'s `reference` at `index` with `target` has been changed from `oldResolveInfo` to `newResolveInfo`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newResolveInfo: <<resolveInfoType>>
* target: <<targetNodeType>>?
* replacedResolveInfo: <<resolveInfoType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`referenceResolveInfoChanged`

.Related command
<<cmd-changeReferenceResolveInfo>>

[[evnt-referenceTargetAdded]]
===== Reference target added
`newTarget` has been added as target to existing entry inside ``parent``'s `reference` at `index` with `resolveInfo`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newTarget: <<targetNodeType>>
* resolveInfo: <<resolveInfoType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`referenceTargetAdded`

.Related command
<<cmd-addReferenceTarget>>

[[evnt-referenceTargetDeleted]]
===== Reference target deleted
Target `deletedTarget` has been deleted from existing entry inside ``parent``'s `reference` at `index` with `resolveInfo`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* resolveInfo: <<resolveInfoType>>
* deletedTarget: <<targetNodeType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`referenceTargetDeleted`

.Related command
<<cmd-deleteReferenceTarget>>

[[evnt-referenceTargetChanged]]
===== Reference target changed
Target of existing entry inside ``parent``'s `reference` at `index` with `resolveInfo` has been changed from `oldTarget` to `newTarget`.

.Parameters
* parent: <<targetNodeType>>
* reference: <<metaPointerType>>
* index: <<indexType>>
* newTarget: <<targetNodeType>>
* resolveInfo: <<resolveInfoType>>?
* replacedTarget: <<targetNodeType>>
* originCommands: <<commandSourceType>>[]

.Technical name
`referenceTargetChanged`

.Related command
<<cmd-changeReferenceTarget>>

[[evnt-composite-section]]
==== Composite

[[evnt-composite]]
===== Composite
The events in `parts` have happened in the given order.

All `originCommands` have been handled (maybe by discarding them).

.Parameters
* parts: <<eventType>>[]
* originCommands: <<commandSourceType>>[]

.Technical name
`composite`

.Related command
<<cmd-composite>>