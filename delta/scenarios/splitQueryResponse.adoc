=== Split query response
[plantuml,splitQueryResponse,svg]
----
hide footbox
autonumber

box "Client A"
  participant Editor as editor
  participant Queries as clientQuery
end box

box "Repository"
  participant Queries  as repoQuery
  participant Core as core
end box

== Client A connected with participation id "participation-a" ==

[->> clientQuery
activate clientQuery
clientQuery -> repoQuery ++: subscribePartition("partition-id", "qry-1")
  repoQuery -> core ++: retrieveDescendants("partition-id")
  return

repoQuery -->> clientQuery: content: [partitionNode, nodeA]\nqueryId: "qry-1"\nsplit: true
activate clientQuery
clientQuery -> clientQuery: bufferPartialResponse
deactivate clientQuery

repoQuery -->> clientQuery: <i>ChunkedQueryResponse</i> \n  chunk:[nodeB]\n  continuedChunkCompleted: false\n  continuedChunkSequenceNumber: 0\n  queryId: "qry-1"
activate clientQuery
clientQuery -> clientQuery: bufferPartialResponse
deactivate clientQuery

repoQuery -->> clientQuery: <i>ChunkedQueryResponse</i> \n  chunk:[nodeC, annotationD]\n  continuedChunkCompleted: true\n  continuedChunkSequenceNumber: 1\n  queryId: "qry-1"
deactivate repoQuery
activate clientQuery
clientQuery -> clientQuery: composeResponse
deactivate clientQuery

clientQuery -> editor
deactivate clientQuery
activate editor
editor -> editor: draw(nodeA, nodeB, nodeC)
----
1. Client knows the relevant partition, wants to subscribe.
2. Client sends <<qry-SubscribeToPartitionContents>> query with partition node id `partition-id`.
3. Repository retrieves all contents of partition with node id `partition-id`.
4. Repository found contents.
5. Repository responds to query with id `qry-1` with contents of 2 nodes: `partitionNode`, `nodeA` (details omitted).
Repository decided the response is too big, and splits it up (`split: true`).
6. Client receives split query result and buffers partial response.
7. Repository continues its response to query with id `qry-1` with another <<qry-ChunkedQueryResponse>> with chunk of 1 node: `nodeB` (details omitted).
This is the first in the sequence of chunked responses (`continuedChunkSequenceNumber: 0`) and there will be another response (`continuedChunkCompleted: false`).
8. Client receives the next split query result and buffers partial response.
9. Repository continues its response to query with id `qry-1` with another <<qry-ChunkedQueryResponse>> with chunk of 2 nodes: `nodeC`, `annotationD` (details omitted).
This is the second in the sequence of chunked responses (`continuedChunkSequenceNumber: 1`) and there will _not_ be another response (`continuedChunkCompleted: true`).
10. Client receives the final next split query result and composes the response.
11. Client forwards information to editor.
12. Client draws `nodeA` and `nodeB`.
`partitionNode` is not drawn, it represents the canvas.
