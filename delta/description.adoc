[[description]]
== Description

[[repository, repository]]
=== Repository characteristics
A repository is a set of partitions, and a set of APIs, amongst them this delta API.
The repository has an ID that must be unique for all repositories in the same context.
LionWeb doesn't specify the scope of the context.{fn-org401}

A repository is “its own universe”: nodes within it can't reference nodes, or be referenced from nodes from other repositories.
All nodes within the same repository MUST have unique IDs.
Nodes can refer to nodes from the LionCore and built-in languages.

[[client, client]]
=== Client characteristics
A client is a program connecting to a <<repository>>.
Each client has exactly one <<participation>> with one repository at one point in time.
The same client can have several consecutive participations with the same repository, but never at the same time.
A client might interact with several repositories, but they are completely independent (i.e. same as two clients connecting to two repositories).{fn-org337}

The client has the responsibility to guarantee uniqueness of <<queryIdType, query ids>> and <<commandIdType, command ids>> within the same participation.

Authentication and authorization are out of scope of this API.

[[channel, channel]]
=== Channel characteristics
Logically, the channel has independent parts for each <<introduction, category>> of message;
in practice, we might transmit some or all of them through a shared channel.

This protocol is agnostic of its underlying transport or technical implementation.
By default, this protocol uses JSON encoding over a text-based, single channel, stateful, bi-directional, asynchronous, reliable, and trustworthy transport.{fn-org429}
Any transport that fits these criteria (e.g. WebSocketfootnote:[https://websockets.spec.whatwg.org/]) MUST use the same encoding and MUST adhere to the <<deltaJsonSchema>>.{fn-org428}

We assume the underlying protocol handles quality of service concerns (i.e. guaranteed one-time complete delivery of messages), they are out of scope of this API.

[[participation, participation]]
=== Participation characteristics
Each participation has a _[[participation-id, participation id]]participation id_, unique for all concurrent participations.
The repository assigns the participation id upon starting a new participation.
The participation id MUST follow the same format as <<{m3}.adoc#identifiers, identifier>>.
It serves as a technical identifier.

A participation is transparent for reconnecting network connections,i.e. one participation can survive potential technical reconnects.
A participation spans over time: if we would e.g. used REST, a participation spans over several REST requests/responses.

A participation <<qry-SignOn, starts>> by the client connecting to the repository via delta protocol.
A participation ends either by the <<qry-SignOff, client ending>> it, or if the client disconnects involuntarily (e.g. by crashing or a connection failure).

A client can try to <<qry-Reconnect, reconnect>> a participation if the client still knows a previously valid participation id, and the last <<event-sequence-number>> the client received.{fn-org349}

[[event-sequence-number, event sequence number]]
=== Event sequence numbers
Each event contains a sequence number.{fn-org341}
This number is a positive integer that increments by one for each consecutive event.
It is unique per participation.{fn-org343}

A <<client>> SHOULD use this number to order incoming events, and check whether the client missed any event.

[[subscription, subscription]]
=== Subscription characteristics
The subscription, or subscription scope, is the set of partitions a <<participation>> gets events for.
A subscription does not have an identity on its own; it is bound to one participation.

Scope is defined by the node id of a <<{m3}.adoc#partition, partition>>; it includes all changes to the partition and all its descendants (including annotation instances).{fn-org269}

At the start of a participation, the subscription scope is empty.
A client can change its subscription scope by <<qry-SubscribeToChangingPartitions, subscribing to newly created partitions>>, or <<qry-SubscribeToPartitionContents, subscribe>> / <<qry-UnsubscribeFromPartitionContents, unsubscribe>> a specific partition.
A client can change the subscription scope at any time during a participation.

A client can send commands for any node id, independent of the client's subscription.
Assume a client sends a command for a node that's part of a partition that client is not subscribed to.
The repository treats that command the same as from a client that was subscribed to the containing partition, i.e. applies it in accordance with the repository's policy.
The repository also sends out the same events to subscribed clients, thus _not_ to the sending client.{fn-org352}

[[message, message]]
=== Message characteristics

[[messageAtomicity]]
.Atomicity
Most messages are atomic; they cannot be split.
The exceptions are <<splittableMessage, splittable messages>>.

[[messageIdentity, message identity]]
.Message identity
Each message has some id unique to the <<participation>>:

* Queries have a <<queryIdType>> (for <<qry-ChunkedQueryResponse>> together with its <<continuedChunkSequenceNumberType>>).
* Commands have a <<commandIdType>> (for <<cmd-ChunkedCommand>> together with its <<continuedChunkSequenceNumberType>>).{fn-org305}
* Events have <<eventSequenceType>>.{fn-org423}

[[technicalName, technical name]]
.Technical name
Every defined message has a unique _technical name_.
The technical name is a valid programming language identifier as described for <<{m3}.adoc#IKeyed, IKeyed>>.
Each binding to a specific protocol might use the technical name in a different way.
For example, a JSON binding might have a member containing the technical name of the message, or a Protobuf binding might use the technical name as type name.

[[splittableMessage, splittable message]]
==== Splittable messages
All messages containing a <<unconstrainedChunkType>>.

A client or repository CAN decide to split up a _splittable message_ if that message would exceed the acceptable message size.
LionWeb does not define the acceptable message size, it SHOULD be a parameter for each implementation.

All _splittable messages_ contain a <<splitFlagType>>.
If the flag is `false`, the splittable message is self-contained.
If the flag is `true`, one or more <<continuedChunk>> messages will follow.{fn-org425}

_Splittable messages_ include:

Queries::
* <<qry-SubscribeToPartitionContents>> response <<SubscribeToPartitionContents.contents>>
* <<qry-ListPartitions>> response <<ListPartitions.partitions>>
* <<qry-ListAndSubscribePartitions>> response <<ListAndSubscribePartitions.partitions>>

Commands::
* <<cmd-AddPartition>> <<AddPartition.newPartition>>
* <<cmd-AddChild>> <<AddChild.newChild>>
* <<cmd-ReplaceChild>> <<ReplaceChild.newChild>>
* <<cmd-AddAnnotation>> <<AddAnnotation.parent>>
* <<cmd-ReplaceAnnotation>> <<ReplaceAnnotation.newAnnotation>>

Events::
* <<evnt-ChildAdded>> <<ChildAdded.newChild>>
* <<evnt-ChildReplaced>> <<ChildReplaced.newChild>>
* <<evnt-AnnotationAdded>> <<AnnotationAdded.newAnnotation>>
* <<evnt-AnnotationReplaced>> <<AnnotationReplaced.newAnnotation>>

[[continuedChunk, continued chunk]]
.Continued chunks
_Continued chunks_ continue the chunk from the related <<splittableMessage>>.
Each _continued chunk_ refers to the <<splittableMessage>> it belongs to.
The _continued chunk_ contains a chunk, a consecutive sequence number, and a <<continuedChunkCompletedFlagType>> to signal whether it is the last _continued chunk_, or more will follow.
If the flag is `true`, this is the last _continued chunk_.
If the flag is `false`, one or more _continued chunk_ messages will follow.{fn-org425}

There MUST NOT be any message in the same <<channel>> between the _chunked message_ and all related _continued chunks_.

_Continued chunks_ include:

* <<qry-ChunkedQueryResponse>>
* <<cmd-ChunkedCommand>>
* <<evnt-ChunkedEvent>>

[[additionalInfo, additional info]]
==== Additional Info
Each message optionally can have one or more _additional infos_ consisting of:{fn-org331}{fn-org332}{fn-org430}

* [[additionalInfo.kind]]`kind` is an <<{m3}.adoc#identifiers, identifier>>-compatible string identifying the additional info type.
Some kinds are pre-defined in this specification.
A repository MAY reply with other, additional kinds.
* [[additionalInfo.distribute]]`distribute`? is an optional <<booleanType>> flag with default value `false`.
It is only valid in <<commands>>, i.e. MUST NOT be used for <<events>> or <<queries>>.
If present and set to `true`, the repository MUST copy the additional info to all events that result from the command, and distribute the additional info to all participants receiving the event.

* [[additionalInfo.message]]`message` is a human-readable string describing the additional info.
* [[additionalInfo.data]]`data` is a flat map with 0 or more arbitrary keys and values.
All keys MUST be <<{m3}.adoc#identifiers, identifier>>-compatible and MUST be unique within the same additional info.
All values MUST be strings.
A _kind_ might imply presence of specific keys in `data`.

This additional info is symmetric to <<{bulk}.adoc#additionalInfo, additional infos in bulk API>>.
