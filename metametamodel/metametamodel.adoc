include::../shared/issue-footnotes.adoc[]
:serialization: ../serialization/serialization
= Meta-Metamodel (M3)
:toc: preamble
:toclevels: 3
:sectnums:


In this document we describe the Meta-Metamodel to be used by LionWeb *version 2024.1*.
The Meta-Metamodel is called LionCore.

[[introduction]]
== Introduction

[[goals]]
=== Goals

The goal is to define a meta-metamodel that can be used in different contexts and implemented from different languages.

The approach taken would be conservative: we want to provide boring and proven infrastructure, so that innovation can be built on top of it.

This will be based on the experience that we as a community had with the meta-metamodel used in EMF and MPS mainly.
Suggestions based on the experience obtained with other meta-metamodels are also very welcome.

=== Languages supported

We aim to have the initial implementations being available in Java and Typescript.
We are interested in implementing it in other languages too, but not as part of the initial effort.

=== What kind of models should be expressible?

Any kind of model.
In other words, models specified using metamodels expressed through this Meta-Metamodel should not make any assumptions on the node being obtained from parsing text or a graphical modeling tool or a projectional editor.
All these possible origins should be supported, with specific extensions were necessary.

For example, metamodels should be expressed to define:

* The Abstract Syntax Tree (AST) of existing textual programming languages such as Java, RPG, Python, or SAS

* The Abstract Syntax Tree (AST) of DSLs backed by projectional editors.
For example, DSLs used to define tax calculations or automation rules for email marketing systems

== Overview

Let’s first see a representation of the meta-metamodel using (a tiny subset of) the UML’s class diagram notation.

plantuml::metametamodel.puml[format=svg]

== Definition of the meta-metamodel

In this section we describe the single elements composing the Meta-Metamodel.
We will list elements by their type: classes, abstract classes and interfaces.

=== Concepts

The concepts are <<Language>>, <<Concept>>, <<Annotation>>, <<Interface>>, <<PrimitiveType>>, <<Enumeration>>, <<EnumerationLiteral>>, <<StructuredDataType>>, <<Field>>, <<Containment>>, <<Reference>>, and <<Property>>.

[[Language]]
==== Language
A Language{fn-org78} will provide the Concepts necessary to describe ideas in a particular domain together with supporting elements necessary for the definition of those Concepts.

It also represents the <<namespaces, namespace>> for <<LanguageEntity, LanguageEntities>>.

.Example
For example, a Language for accounting could collect several Concepts such as _Invoice_, _Customer_, _InvoiceLine_, _Product_.
It could also contain related elements necessary for the definitions of the concepts.
For example, a DataType named Currency.

.EMF & MPS equivalent
A Language in LionWeb will be roughly equivalent to an `EPackage` or the contents of the _structure aspect_ of an MPS Language.

A Language will not have a URI or a prefix, differently from EPackages.

A Language will have a version string, different from MPS Languages' version number.

Differently from EPackages and MPS Languages, there is no way to group language elements.
EPackages have instead sub-packages and MPS Languages have virtual folders.
For this use case, different Languages could be used instead.

.Characteristics
A Language has a <<INamed.name, `name`>>, a <<IKeyed.key, `key`>>{fn-org90}, and a [[Language.version, Language.version]]`version`{fn-org7}{fn-org92}, similar to MPS Languages.

[[Language.entities, Language.entities]]
Each Language will contain a list of <<LanguageEntity, Language entities>> in its `entities` containment.

A Language is an <<INamed>> (as it has a name) and an <<IKeyed>> (as it has a key){fn-org142}.

[[Language.dependsOn, Language.dependsOn]]
A Language can depend on other Languages via `dependsOn` reference.{fn-org145}
Dependencies must be explicitly declared.{fn-org50}

.Constraints
`version` can be any non-empty string.{fn-org130}{fn-org131}

Language elements contained in a Language are allowed to refer to these other Language elements:{fn-org50}

* within the same language
* within declared dependencies
* within _transitive_ dependencies.
+
Example: if Language _B_ depends on Language _A_, and Language _C_ depends on _B_, then Language _C_ can also refer to members of Language _A_ without explicitly declaring a dependency.

A Language CAN declare a transitive dependency explicitly.
In the example above, Language _C_ CAN declare an explicit dependency on Language _A_.

As any Language depends (at least transitively and <<Concept.extends, implicitly>>) on <<builtins>> elements, a Language CAN declare a dependency on builtins -- but _does not_ need to.{fn-org153}

[[Concept]]
==== Concept
A Concept represents a category of entities sharing the same structure.

.Example
For example, _Invoice_ would be a Concept.
Single entities could be Concept instances, such as Invoice #1/2022.

.EMF & MPS equivalent
A Concept is roughly equivalent to an `EClass` (with the `isInterface` flag set to `false`) or an MPS’s `ConceptDeclaration`.

.Characteristics
A Concept has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

[[Concept.abstract, Concept.abstract]]
A Concept can be concrete (i.e., instantiable) or abstract, marked by boolean `abstract` property.

[[Concept.partition, Concept.partition]]
A Concept can be marked as <<partition, partition>> via the boolean `partition` property.{fn-org29}

A Concept is a <<Classifier>>  (as it has features).
It is indirectly a <<LanguageEntity>> (as it is a top level element in a <<Language>>), an <<INamed>> (as it has a name), a <<IKeyed>> (as it has a key).

[[Concept.extends, Concept.extends]]
Each Concept `extends` zero or one Concepts.
If no Concepts are explicitly extended, the Concept will implicitly extend the Concept <<Node>>.
`Node` is the only concept that truly does not extend any Concept.

[[Concept.implements, Concept.implements]]
A Concept `implements` zero or more <<Interface, Interfaces>>.

A Concept can have any number of <<Classifier.features, `features`>>, given it is a <<Classifier>>.

.Constraints
A Concept MUST NOT extend itself, or form circles via `extends`.

[[Annotation]]
==== Annotation
An Annotation is an additional piece of information attached to potentially any node, sharing the node’s lifecycle.
The annotated node (or its concept) does not need to know about the annotation.{fn-org13}
Annotations CAN be attached to other Annotations (although this structure is hard to comprehend, and should be used with caution).

Annotations should only have limited content because the more complex the annotation is, the more likely it should not be part of the annotated node's lifecycle -- We might want to reuse the complex annotation somewhere else. +
Example: In MPS, the editor of a concept can be seen as an annotation of that concept.
But even if we deleted the concept, we might want to reuse the editor for another (similar) concept.

Annotations' contents should be orthogonal to the annotated node, because actual content should be part of the original concepts, and unrelated contents should be somewhere else. +
Example: Let's assume our Language defines a `Date` PrimitiveType.
We might annotate `Date` with `@JavaImplementation(java.util.Date)` and `@TypeScriptImplementation(JsJoda.LocalDate)`.
Our core model stays platform-independent, but we maintain the implementation details at the right place -- if we ever deleted `Date`, all related information would be gone without further cleanup.

.Example
We design a fancy documentation language, and can annotate any other node with such documentation.

.EMF & MPS equivalent
An Annotation is equivalent to MPS' `NodeAttribute`.
In EMF, an `Adapter` can be used for similar purposes on M1 models.
On M2 models (i.e. Ecore), an Annotation corresponds to an `EAnnotation`.

.Characteristics
An Annotation has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

An Annotation is a <<Classifier>>, and indirectly a <<LanguageEntity>> (as it is a top level element in a <<Language>>), an <<INamed>> (as it has a name), a <<IKeyed>> (as it has a key).

[[Annotation.annotates, Annotation.annotates]]
Each Annotation specifies which <<Classifier, `Classifiers`>> it `annotates`.
If it should be applicable to any node, it annotates <<Node>>.

Annotations can specify which Annotation it [[Annotation.extends, Annotation.extends]]`extends` and which interfaces it [[Annotation.implements, Annotation.implements]] `implements`.
An Annotation CAN have any number of <<Classifier.features, `features`>>, given it is a <<Classifier>>.

.Constraints
We CANNOT redefine `annotates` in a sub-annotation (i.e. an annotation that `extends` another).{fn-org154}

We MUST attach an instance of an Annotation only to instances of the Concept the Annotation `annotates` (and sub-concepts thereof).
We can attach zero, one, or more instances to a single annotated node.{fn-org32}

We MUST NOT use instances of <<Concept, Concepts>> as annotations to any other node.{fn-org320}

.Annotation examples
--
.Language
[plantuml, valid-annotation, svg]
----
hide empty members

annotation DocumentationAnnotation <<A, orange>><<Annotation>> {
  docu: String
}

DocumentationAnnotation -> Builtins.Node: annotates

annotation OrgRoleAnnotation <<A, orange>><<Annotation>> {
  role: String
}

OrgRoleAnnotation -> Person: annotates

package Builtins {
  class Node <<C, lightgreen>><<Concept>>
}

class Person <<C, lightgreen>><<Concept>> extends Builtins.Node {
  partition = false
  --
  name: String
  age: Integer
}

Person *- Address

class Address <<C, lightgreen>><<Concept>> extends Builtins.Node {
  partition = false
  --
  street: String
  zipcode: String
}
----

.Valid instance
[plantuml, valid-annotation-m1, svg]
----
hide empty members

class Alice <<c, lightgreen>><<Person>> {
  name = "Alison"
  age = 23
}

Alice *- CompanyAddress

class CompanyAddress <<c, lightgreen>><<Address>> {
  street = "main st."
  zipcode = "3212"
}

class AliceRole1 <<a, orange>><<OrgRoleAnnotation>> {
  role = "CEO"
}
Alice <-- AliceRole1

class AliceRole2 <<a, orange>><<OrgRoleAnnotation>> {
  role = "Founder"
}
Alice <-- AliceRole2

class AliceDocu <<a, orange>><<DocumentationAnnotation>> {
  docu = "Loves dogs"
}
Alice <-- AliceDocu

class CompanyAddrDocu <<a, orange>><<DocumentationAnnotation>> {
  docu = "The place where work happens"
}

CompanyAddress <-- CompanyAddrDocu
----

.Invalid instance
[plantuml, invalid-annotation-m1, svg]
----
hide empty members

class Alice <<c, lightgreen>><<Person>> {
  name = "Alison"
  age = 23
}

Alice *- CompanyAddress

class CompanyAddress <<c, lightgreen>><<Address>> {
  street = "main st."
  zipcode = "3212"
}

class AliceDocu1 <<a, orange>><<DocumentationAnnotation>> ##red {
  role = "Loves dogs"
}
Alice <-[#red]- AliceDocu1


class CompanyRole <<a, orange>><<OrgRoleAnnotation>> ##red {
  role = "invalid because\nOrgRoleAnnotation.annotates!=Address"
}

CompanyAddress <-[#red]- CompanyRole
----
--

[[Interface]]
==== Interface
An Interface{fn-org190} represents a category of entities sharing some similar characteristics.

.Example
For example, `Named` would be an Interface.

.EMF & MPS equivalent
An Interface in LionWeb will be roughly equivalent to an `EClass` (with the `isInterface` flag set to `true`) or an MPS’s `ConceptInterfaceDeclaration`.

.Characteristics
An Interface has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

An Interface is an <<Classifier>>  (as it has features).
It is indirectly a <<LanguageEntity>> (as it is a top level element in a <<Language>>), an <<INamed>> (as it has a name), a <<IKeyed>> (as it has a key).

[[Interface.extends, Interface.extends]]
Each Interface `extends` zero or more Interfaces.

An Interface can have any number of <<Classifier.features, `features`>>, given it is a <<Classifier>>.

.Constraints
{empty}

[[PrimitiveType]]
==== PrimitiveType
This represents an arbitrary primitive value, which is not an <<Enumeration>>.

.Example
_BooleanType_, _NumberType_, and _StringType_ are common PrimitiveTypes.

.EMF & MPS equivalent
A PrimitiveType is similar to Ecore’s `EDataType` and to MPS’ `PrimitiveDataTypeDeclaration`.

Differently from ECore’s `EDataType` PrimitiveType has no flag `serializable`, and it does not inherit fields such as `instanceClassName`, `instanceClass`, or `defaultValue`.

.Characteristics
A PrimitiveType has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

A PrimitiveType is a <<DataType>> (as it can be used as <<Property.type, type>> of a <<Property>>).
It is indirectly a <<LanguageEntity>> (as it is a top level element in a <<Language>>), an <<INamed>> (as it has a name) and a <<IKeyed>> (as it has a key).

The correspondence between a PrimitiveType and an implementation class on a specific platforms can be specified through annotations, but it is not specified on the PrimitiveType itself.

.Constraints
We consider a PrimitiveType as opaque value type without structure or identity.

[[Enumeration]]
==== Enumeration
A primitive value with finite, pre-defined, known set of possible values.

.Example
_DaysOfWeek_ or _PlayingCardSuit_ are common Enumerations.

.EMF & MPS equivalent
An Enumeration is similar to Ecore’s `EEnum` and to MPS’ `EnumerationDeclaration`.

Differently from ECore’s `EEnum` Enumeration has no flag `serializable`, and it does not inherit fields such as `instanceClassName`, `instanceClass`, or `defaultValue`.

.Characteristics
An Enumeration has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

[[Enumeration.literals, Enumeration.literals]]
An Enumeration contains <<EnumerationLiteral, EnumerationLiterals>> in its `literals` containment.
It also represents the <<namespaces, namespace>> for the EnumerationLiterals.

An Enumeration is a <<DataType>> (as it can be used as <<Property.type, type>> of a <<Property>>).
It is indirectly a <<LanguageEntity>> (as it is a top level element in a <<Language>>), an <<INamed>> (as it has a name) and a <<IKeyed>> (as it has a key).

.Constraints
Implementations should use native representations for Enumerations, e.g. a `enum` in a Java implementation.

[[EnumerationLiteral]]
==== EnumerationLiteral
One of the possible values of an <<Enumeration>>.

.Example
_Monday_, _Tuesday_, _Wednesday_, _Thursday_, _Friday_, _Saturday_ and _Sunday_ are all EnumerationLiterals of the _DaysOfWeek_ Enumeration.

.EMF & MPS equivalent
An EnumerationLiteral is similar to Ecore’s `EEnumLiteral` and to MPS’ `EnumerationMemberDeclaration`.

.Characteristics
An EnumerationLiteral has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

An EnumerationLiteral is a <<IKeyed>> (as it has a key) and indirectly an <<INamed>> (as it has a name).

.Constraints
Each EnumerationLiteral must have a unique `name` within the Enumeration.

Each EnumerationLiteral belongs to one and only one Enumeration.

[[StructuredDataType]]
==== StructuredDataType
Represents a collection of named instances of <<DataType, Data Types>>.
They are meant to support a small composite of values that semantically form a unit.
Instances of StructuredDataTypes have no identity, are always copied by value, and SHOULD be immutable.{fn-org265}
Two instances of a StructuredDataType that hold the same values for all fields of that StructuredDataType are interchangeable.
(Instances of <<Classifier, Classifiers>> have an identity, through <<Node.id, `id`>>.)

.Example
We could represent a "Complex number { real part, imaginary part }" or "Color { red, green, blue }" as StructuredDataType.

.EMF & MPS equivalent
No direct similarities.
We could simulate it by a custom `EDatatype` in ECore.

.Characteristics
[[StructuredDataType.fields, StructuredDataType.fields]]
A StructuredDataType contains <<Field, Fields>> in its `fields` containment.
It also represents the <<namespaces, namespace>> for the fields.

A StructuredDataType has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

A StructuredDataType is a <<DataType>> (as it can be used as <<Property.type, type>> of a <<Property>>).
It is indirectly a <<LanguageEntity>> (as it is a top level element in a <<Language>>), an <<INamed>> (as it has a name) and a <<IKeyed>> (as it has a key).

.Constraints
M1 Instances of a StructuredDataType SHOULD be immutable.

An M1 instance of StructuredDataType MUST have non-null values for all its fields.

A StructuredDataType MUST NOT (directly or indirectly) contain a field with itself as `type`.{fn-org265}


[[Field]]
==== Field
Represents one part of a <<StructuredDataType>>.{fn-org265}

.Example
In the StructuredDataType "Complex number", we would have two fields "real part" and "imaginary part".
A StructuredDataType "Color" had the fields "red", "green", and "blue".

.EMF & MPS equivalent
No direct similarities.

.Characteristics
A Field has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

[[Field.type, Field.type]]
A Field refers its `type`, which is a <<DataType>>.

A Field is an <<IKeyed>> (as it has a key) and indirectly an <<INamed>> (as it has a name).

.Constraints
Each Field MUST have a unique `name` within its containing StructuredDataType.

Each Field belongs to one and only one StructuredDataType.


[[Containment]]
==== Containment
Represents a relation between a containing <<Classifier>> and a contained <<Classifier>>.

.Example
Between an _IfStatement_ and its _condition_ there is a Containment relation.

.EMF & MPS equivalent
A Containment is similar to an ECore’s `EReference` with the `containment` flag set to `true`.
Differently from an `EReference` there is no `container` flag and `resolveProxies` flag.

A Containment is similar to an MPS’s `LinkDeclaration` with `metaClass` having value `aggregation`.
Differently from a `LinkDeclaration` there is no field `unordered`.

.Characteristics
A Containment has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.
It can be marked as <<Feature.optional, `optional`>> and <<Link.multiple, `multiple`>>.

A Containment refers its <<Link.type, `type`>>, which is a <<Classifier>>.

A Containment is a <<Link>> (as it describes a relation between two Classifiers).
It is indirectly a <<Feature>> (as it describes the characteristics of a <<Classifier>>), an <<INamed>> (as it has a name) and a <<IKeyed>> (as it has a key).

.Constraints
Each node, except <<partition>>, must be contained once in exactly one Containment.

The implicit inverse relation of a Containment is called [[parent, parent]]_parent_.
Example: An IfStatement _contains_ its condition.
Then, the condition's _parent_ is the IfStatement.

Instances in containments MUST NOT form a direct or indirect circle:
If node _a_ contains node _b_, node _b_ MUST NOT contain _a_ (direct containment circle).
If the same node _b_ contains node _c_, _c_ MUST NOT contain _a_ (indirect containment circle).
However, Concept _A_ can have a Containment of type _A_.
Concept _A_ with Containment of type _B_, with Concept _B_ having a Containment of type _A_, is also valid.

We MUST NOT use <<Annotation, Annotations>> as type of a Containment.
We MUST put instances of <<Concept, Concepts>> into a containment on M1 level; we MUST NOT use  instances of Annotations.{fn-org320}

[[Reference]]
==== Reference
Represents a relation between a referring <<Classifier>> and referred <<Classifier>>.

.Example
_VariableReference_ may have a Reference to a _VariableDeclaration_.

.EMF & MPS equivalent
A Reference is similar to an ECore’s `EReference` with the `containment` flag set to `false`.
Differently from an `EReference` there is no `container` flag and `resolveProxies` flag.

A Reference is similar to an MPS’s `LinkDeclaration` with `metaClass` having value `reference`.
Differently from a `LinkDeclaration` there is no field `unordered`.

.Characteristics
A Reference has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.
It can be marked as <<Feature.optional, `optional`>> and <<Link.multiple, `multiple`>>.

A Containment refers its <<Link.type, `type`>>, which is a <<Classifier>>.

A Reference is a <<Link>> (as it describes a relation between two Classifiers).
It is indirectly a <<Feature>> (as it describes the characteristics of a <<Classifier>>), an <<INamed>> (as it has a name) and a <<IKeyed>> (as it has a key).

.Constraints
A multiple Reference MAY refer to the same target more than once.
Example: We have nodes _p1_ and _p2_ of Concept Procedure.
Concept StackTrace has a multiple reference "frames" of type Procedure.
An instance of StackTrace can have frames refer to _[p1, p2, p1]_.

[[Property]]
==== Property
This indicates a simple value associated to an entity.

.Example
For example, an _Invoice_ could have a _date_ or an _amount_.

.EMF & MPS equivalent
A Property is similar to Ecore’s `EAttribute`.

A Property is similar to MPS’s `AttributeDeclaration`.

.Characteristics
A Property has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.
It can be marked as <<Feature.optional, `optional`>>.

[[Property.type, Property.type]]
A Property refers its `type`, which is a <<DataType>>.

A Property is a <<Feature>> (as it describes the characteristics of a <<Classifier>>).
It is indirectly a <<IKeyed>> (as it has a key) and an <<INamed>> (as it has a name).

.Constraints
Properties are always single-valued.{fn-org289}.

=== Abstract concepts

The abstract concepts are <<LanguageEntity>>, <<Classifier>>, <<DataType>>, <<Feature>>, and <<Link>>.

[[LanguageEntity]]
==== LanguageEntity
A LanguageEntity is an entity with an identity directly contained in a <<Language>>.

.Example
For example, _Invoice_, _Currency_, _Named_, or _String_ could be LanguageEntities.

.EMF & MPS equivalent
LanguageEntity is similar to Ecore’s `EClassifier`.

LanguageEntity is similar to MPS’ `IStructureElement`.
The difference is that `IStructureElement` includes also elements that cannot appear as top level elements of a structure aspects, such as `LinkDeclaration`, `PropertyDeclaration`, and `EnumerationMemberDeclaration`.

.Characteristics
A LanguageEntity has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

A LanguageEntity is a <<IKeyed>> (as it has a key), and indirectly an <<INamed>> (as it has a name).

A LanguageEntity can be one of:

* <<Annotation>>
* <<Concept>>
* <<Interface>>
* <<Enumeration>>
* <<PrimitiveType>>
* <<StructuredDataType>>

.Constraints
Each LanguageEntity must have a unique `name` within the Language.

Each LanguageEntity belongs to one and only one Language.

[[Classifier]]
==== Classifier
Something which can own <<Feature, Features>>.{fn-org105}

.Example
A Concept can have several features.

.EMF & MPS equivalent
Classifier is similar to `EClass` in Ecore (which is used both for classes and interfaces) and to `AbstractConceptDeclaration` in MPS.

.Characteristics
A Classifier has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

It also represents the <<namespaces, namespace>> for <<Feature, Features>>.


[[Classifier.features, Classifier.features]]
A Classifier owns any number of <<Feature, Features>> in `features` containment.

A Classifier can be one of:

* <<Annotation>>
* <<Concept>>
* <<Interface>>

A Classifier is a <<LanguageEntity>> (as it is a top level element in a <<Language>>).
It is indirectly a <<IKeyed>> (as it has a key) and an <<INamed>> (as it has a name).

[[DataType]]
==== DataType
A type of value which has no relevant identity in the context of a model.

.Example
A _Currency_ or a _Date_ type.

.EMF & MPS equivalent
It is similar to Ecore’s `EDataType`.

It is similar to MPS’ `DataTypeDeclaration`.

.Characteristics
A DataType has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

A DataType is a <<LanguageEntity>> (as it is a top level element in a <<Language>>).
It is indirectly a <<IKeyed>> (as it has a key) and an <<INamed>> (as it has a name).

A DataType can be one of:

* <<PrimitiveType>>
* <<Enumeration>>
* <<StructuredDataType>>

.Constraints
We consider a DataType as value type without identity.
Implementations can choose to copy, compare, or process DataType values by value.

[[Feature]]
==== Feature
A Feature represents a characteristic or some form of data associated with a particular <<Classifier>>.

.Example
For example, an _Invoice_ can have an associated _date_, a _number_, a connection with a _customer_, and it can contain _InvoiceLines_.
All of this information is represented by features.

.EMF & MPS equivalent
A Feature in LionWeb will be roughly equivalent to an `EStructuralFeature` or to the combination of `Properties` and `Links` (both containment and reference links) in MPS.

Differently from Ecore’s `EStructureFeature`, Features do not have flags such as `changeable`, `volatile`, `transient`, or `unsettable`.
They have no `default value`.

Different from MPS' `Link`, Features CANNOT be specialized.{fn-org8}

.Characteristics
A Feature has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.

[[Feature.optional, Feature.optional]]
A Feature can be set to `optional` or required.

A Feature is a <<IKeyed>> (as it has a key) and indirectly an <<INamed>> (as it has a name).

A Feature can either be one of:

* <<Property>>
* <<Containment>>
* <<Reference>>

.Constraints
Each Feature MUST have a unique name within a specific <<Classifier>>, including all (directly or indirectly) inherited Features.{fn-org139}

We CAN have non-unique _inherited_ feature _names_, as in this example:

[plantuml, name-clash, svg]
----
class A {
  <i>id = 123</i>
  <i>key = MyLang-A</i>
  --
  f: string <i>id=332, key=A-f</i>
}

class B {
  <i>id = 12</i>
  <i>key = MyLang-B</i>
  --
  f: integer <i>id=27, key=B-f</i>
}

class X extends A, B {
  <i>id = 79</i>
  <i>key = MyLang-X</i>
  --
}
----

However, within LionWeb we always use a Feature's _id_ or _key_ to for identification.
Thus, LionWeb can deal with the name clash.

If a host language cannot handle this situation, the generator towards that language needs to resolve it.{fn-org97}

[[Link]]
==== Link
Represent a connection to a <<Classifier>>.

.Example
An _Invoice_ can be connected to its _InvoiceLines_ and to a _Customer_.

.EMF & MPS equivalent
It is similar to Ecore’s `EReference`.

It is similar to MPS’ `LinkDeclaration`.

.Characteristics
A Link has a <<INamed.name, `name`>> and an <<IKeyed.key, `key`>>.
It can be marked as <<Feature.optional, `optional`>>.

[[Link.multiple, Link.multiple]]
A Link can have `multiple` or only a single targets.

[[Link.type, Link.type]]
A Link refers its `type`, which is a <<Classifier>>.

A Link is a <<Feature>> (as it describes the characteristics of a <<Classifier>>).
It is indirectly a <<IKeyed>> (as it has a key) and an <<INamed>> (as it has a name).

A Link can be either a <<Containment>>, or a <<Reference>>.

.Constraints
We do NOT support link specialization.{fn-org8}


=== Interfaces

The interfaces are <<IKeyed>>.

[[IKeyed]]
==== IKeyed
Something with a name that has a key.{fn-org142}{fn-org143}

.Example
A Concept _Invoice_, contained in a Language `com.foo.Accounting`.

.EMF & MPS equivalent
n/a

.Characteristics
[[IKeyed.key, IKeyed.key]]
An IKeyed has a <<INamed.name, `name`>> and an `key`.{fn-org90}

A IKeyed is an <<INamed>> (as it has a name).

All elements of the Meta-Metamodel realize `IKeyed`.

.Constraints
A IKeyed's `name` MUST be unique within the namespace (i.e. <<Language>>, <<Classifier>>, or <<Enumeration>>).
The name MUST be a valid programming language identifier{fn-org48}.

More specifically, we allow https://docs.oracle.com/javase/specs/jls/se20/html/jls-3.html#jls-3.8[Java identifiers]  with the following modifications:

* We do NOT allow `$` (dollar sign)
* _ReservedKeyword_, _BooleanLiteral_, and _NullLiteral_ (as per Java identifier spec) are allowed identifiers.

Effectively:

* Names MUST NOT start with a number.
* Names MUST NOT be empty.
* Names MUST NOT contain spaces.
* Names CAN use Unicode characters, numbers, and underscore.

NOTE: These restrictions only apply to names of Language elements (i.e. M3 concepts/M2 instances).
Any language that uses `INamed` on its own can establish their own constraints.

Refer to <<keys>> for more constraints.

[[predefined-keys]]
=== Pre-defined keys and resolveInfos
We can serialize <<Language, languages>> as regular nodes.
To keep the serialized form of the language compatible with multiple LionWeb versions. we SHOULD serialize references to M3 elements and <<builtins>> _without_ <<{serialization}.adoc#Reference.reference.reference, target reference id>>, and include the <<{serialization}.adoc#Reference.reference.resolveInfo, resolveInfo>> as listed in this section.{fn-org279}

[[predefined-m3-keys]]
==== Keys and resolveInfos of M3 elements
The language itself has key `LionCore-M3`{fn-org91} and is named `LionCore_M3`{fn-org195}.

[cols="d,d,m,m"]
|===
|M3 element |Concept |Key |ResolveInfo

|<<Annotation>> |Concept |Annotation |LionWeb.LionCore_M3.Annotation
|<<Annotation.annotates>> |Reference |Annotation-annotates  |LionWeb.LionCore_M3.Annotation.annotates
|<<Annotation.extends>> |Reference |Annotation-extends |LionWeb.LionCore_M3.Annotation.extends
|<<Annotation.implements>> |Reference |Annotation-implements |LionWeb.LionCore_M3.Annotation.implements
|<<Classifier>> |Concept |Classifier |LionWeb.LionCore_M3.Classifier
|<<Classifier.features>> |Containment |Classifier-features |LionWeb.LionCore_M3.Classifier.features
|<<Concept>> |Concept |Concept |LionWeb.LionCore_M3.Concept
|<<Concept.abstract>> |Property |Concept-abstract |LionWeb.LionCore_M3.Concept.abstract
|<<Concept.extends>> |Reference |Concept-extends |LionWeb.LionCore_M3.Concept.extends
|<<Concept.implements>> |Reference |Concept-implements |LionWeb.LionCore_M3.Concept.implements
|<<Containment>> |Concept |Containment |LionWeb.LionCore_M3.Containment
|<<DataType>> |Concept |DataType |LionWeb.LionCore_M3.DataType
|<<Enumeration>> |Concept |Enumeration |LionWeb.LionCore_M3.Enumeration
|<<Enumeration.literals>> |Containment |Enumeration-literals |LionWeb.LionCore_M3.Enumeration.literals
|<<EnumerationLiteral>> |Concept |EnumerationLiteral |LionWeb.LionCore_M3.EnumerationLiteral
|<<Feature>> |Concept |Feature |LionWeb.LionCore_M3.Feature
|<<Feature.optional>> |Property |Feature-optional |LionWeb.LionCore_M3.Feature.optional
|<<Field>> |Concept |Field |LionWeb.LionCore_M3.Field
|<<Field.type>> |Reference |Field-type |LionWeb.LionCore_M3.Field.type
|<<IKeyed>> |Interface |IKeyed |LionWeb.LionCore_M3.IKeyed
|<<IKeyed.key>> |Property |IKeyed-key |LionWeb.LionCore_M3.IKeyed.key
|<<Interface>> |Concept |Interface |LionWeb.LionCore_M3.Interface
|<<Interface.extends>> |Reference |Interface-extends |LionWeb.LionCore_M3.Interface.extends
|<<Language>> |Concept |Language |LionWeb.LionCore_M3.Language
|<<Language.dependsOn>> |Reference |Language-dependsOn |LionWeb.LionCore_M3.Language.dependsOn
|<<Language.entities>> |Containment |Language-entities |LionWeb.LionCore_M3.Language.entities
|<<Language.version>> |Property |Language-version |LionWeb.LionCore_M3.Language.version
|<<LanguageEntity>> |Concept |LanguageEntity |LionWeb.LionCore_M3.LanguageEntity
|<<Link>> |Concept |Link |LionWeb.LionCore_M3.Link
|<<Link.multiple>> |Property |Link-multiple |LionWeb.LionCore_M3.Link.multiple
|<<Link.type>> |Reference |Link-type |LionWeb.LionCore_M3.Link.type
|<<PrimitiveType>> |Concept |PrimitiveType |LionWeb.LionCore_M3.PrimitiveType
|<<Property>> |Concept |Property |LionWeb.LionCore_M3.Property
|<<Property.type>> |Reference |Property-type |LionWeb.LionCore_M3.Property.type
|<<Reference>> |Concept |Reference |LionWeb.LionCore_M3.Reference
|<<StructuredDataType>> |Concept |StructuredDataType |LionWeb.LionCore_M3.StructuredDataType
|<<StructuredDataType.fields>> |Containment |StructuredDataType-fields |LionWeb.LionCore_M3.StructuredDataType.fields
|===

[[predefined-builtins-keys]]
==== Keys and resolveInfos of built-in elements
The language hosting built-in elements has id and key `LionCore-builtins`{fn-org141}, its name is `LionCore_builtins`{fn-org195}.

Every language implicitly depends on this language.{fn-org9-implicit}
Thus, the ids in this language MUST be stable.
This means the id MUST be identical to the key for each node in this language.

[cols="d,d,m,m"]
|===
|Instance |Concept |Key |ResolveInfo

|<<Boolean>> |PrimitiveType |LionCore-builtins-Boolean |LionWeb.LionCore_builtins.Boolean
|<<INamed>> |Interface |LionCore-builtins-INamed |LionWeb.LionCore_builtins.INamed
|<<INamed.name, INamed.name>> |Property |LionCore-builtins-INamed-name |LionWeb.LionCore_builtins.INamed.name
|<<Integer>> |PrimitiveType |LionCore-builtins-Integer |LionWeb.LionCore_builtins.Integer
|<<Node>> |Concept |LionCore-builtins-Node |LionWeb.LionCore_builtins.Node
|<<String>> |PrimitiveType |LionCore-builtins-String |LionWeb.LionCore_builtins.String
|===


[[builtins, built-ins]]
=== Built-in elements
Each LionWeb implementation ships with a set of built-in elements, akin to a _standard library_.{fn-org195}
These elements are part of the M2 language <<predefined-builtins-keys, `LionCore_builtins`>>.
It can be used in any user-defined Language.{fn-org196}

plantuml::builtins.puml[format=svg]

==== Concepts

[[Node, Node]]
* `Node`{fn-org71}, an _abstract_ <<Concept>> that's the (explicit or implicit) the ancestor of all concepts.

==== Interfaces

[[INamed, INamed]]
* `INamed`{fn-org86}, an <<Interface>> with one <<Property>> called [[INamed.name]]`name` of type <<String>>.
+
If a <<Link.type, Reference.type>> targets a Classifier that implements INamed, implementations SHOULD use the target's `name` property as default <<{serialization}.adoc#Reference.reference.resolveInfo, resolveInfo>> value.

==== Primitive types

Some <<PrimitiveType, primitive types>> will be widely used, so it makes sense to pre-define them.{fn-org9}

* [[Boolean, Boolean]] `Boolean` with exactly two values: `true` and `false` (<<{serialization}.adoc#boolean, Details>>)
* [[String, String]] `String`, an arbitrary-length series of Unicode characters (<<{serialization}.adoc#string, Details>>)
* [[Integer, Integer]] `Integer`, an arbitrary-length positive or negative integer number (<<{serialization}.adoc#integer, Details>>)


=== Supporting terminology
==== Multiplicity
Multiplicity describes how many targets a <<Link>> must and can have.

.Example
Common multiplicities are `1` (meaning there MUST be exactly one target), `0..1` (meaning there CAN be exactly one target), `0..\*` (meaning there CAN be zero or more targets), and `1..*` (meaning there MUST be at least one target, but there CAN be more than one targets).

.EMF & MPS equivalent
In Ecore there is no equivalent as `lowerBound` and `upperBound` can be set independently.

This is equivalent to MPS’ `Cardinality`, which has the four values mentioned as example.

.Characteristics
LionCore represents multiplicity as the two booleans <<Feature.optional, `optional`>> (whether there MUST be at least one target) and <<Link.multiple, `multiple`>> (whether there CAN be more than one target).

[%autowidth]
|===
|Multiplicity |`optional` |`multiple`
|`1` |true |false
|`0..1` |false |false
|`0..*` |true |true
|`1..*` |false |true
|===


[[partition]]
==== Partitions
Each node that does not have a parent node MUST be of a Concept with <<Concept.partition, partition>> flag set to `true`.
This implies that every node is contained in exactly one partition, namely the partition defined by its root node.{fn-org29}
Partitions CANNOT be nested.

.EMF & MPS equivalent
A partition is similar to ECore's `Resource`.

A partition is similar to MPS' `model`.

[[identifiers]]
==== Identifiers

===== Valid characters

Ids can only contain these symbols:

* lowercase latin characters: `a`..`z`
* uppercase latin characters: `A`..`Z`
* arabic numerals: `0`..`9`
* underscore: `_`
* hyphen: `-`

This is the same character set as https://en.wikipedia.org/wiki/Base64#Variants_summary_table[Base64url variant].

===== Representation

Ids are represented by a string, containing only valid characters (as defined above).
An id string is NOT padded, also not by whitespaces.
An id string does NOT contain any terminating symbols (compared to some BASE64 variants); this does not affect internal representation in a specific implementation language, e.g. C-style \0-terminated strings.

===== Scope

Node ids MUST be unique within their id-space.

[[id-space]]
====== Id-space

An id-space is a realm that guarantees the uniqueness of all ids within.
Typically, this means one repository.

An id-space has an id as defined above.
Uniqueness of id-space ids is out of scope of LionWeb specification.

In LionWeb (the protocol), id-spaces are NOT hierarchical.
An implementation might choose to use hierarchical id-spaces internally.

[[node-id]]
===== Identification

A node can be identified relative to its id-space by the node's id.
To globally identify a node, we use the combination of the id-space id and the node id.

[[keys]]
==== Keys
We use keys when we refer from _instance level_ to _meta level_.{fn-org80}
Refer to <<references-to-language-elements>> for a list of all usages.

Keys are modeled via <<IKeyed.key>>.
Keys MUST be valid <<identifiers>>.

A key SHOULD be globally unique, and MUST be unique within an <<id-space>>, i.e.  the Language.{fn-org91}
For approximate global uniqueness, we SHOULD adopt Java's package naming scheme, based on domain names.
As we don't allow dots (`.`) in ids, we SHOULD use dashes (`-`) instead.

[[namespaces]]
==== Namespaces
A Namespace implements <<INamed>> and can have descendants that implement <<INamed>>.

Typically, a namespace enforces some constraints on the contained names, like uniqueness within the same namespace, or what's considered a valid name.

We can calculate a fully qualified name by concatenating the namespaces of all the ancestors up to the top level ancestor.
Future versions might support this directly.{fn-org146}

== Other considerations

=== Reflection

Reflection describes the ability of each Meta-Metamodel instance to access the definition of the Meta-Metamodel element from which it has been instantiated.

It is important to offer this functionality also in consideration that some implementation languages may not offer reflection capabilities that could be used as an alternative.

=== Generics

Generics are not directly supported by this proposal.
We could solve some needs through specialization of features in derived classes.
We could alternatively also imagine using specific annotations for supporting this.

In general Generics complicate the solution and MPS can live without them.
Also, in StarLasu we never encountered the need for them so far.

[[references-to-language-elements]]
=== References to language elements
From a language, we refer to all language elements by their <<node-id, id>>.{fn-org131}
This includes references to

* <<Language.dependsOn, other languages>>
* extended <<Concept.extends, Concepts>>
* <<Interface.extends, extended>> or <<Concept.implements, implemented>> Interfaces
* Types of <<Property.type, Properties>> or <<Link.type, Links>>

As <<builtins>> is just another language, we refer to its members by their id, just as any other language members.

From an instance, we refer to its defining language element by the language element's <<keys>>{fn-org80}
This includes references to

* <<Language>> usage
* <<Annotation>> or <<Concept>> instance
* <<Property>> assignment
* <<Containment>> assignment
* <<Reference>> assignment
* <<EnumerationLiteral>> value


=== Union or intersection types

These are not supported.

=== Operations

Operations are not represented in the Meta-Metamodel.

== Reference models

=== Meta-meta model
The LionCore model, aka LionWeb M3.
It is link:lioncore.json[defined] by means of itself, as outlined by link:https://en.wikipedia.org/wiki/Meta-Object_Facility[Meta-Object Facility].

[source, json]
----
include::lioncore.json[]
----

=== Pre-defined elements
The LionCore link:builtins.json[built-in] elements.

[source, json]
----
include::builtins.json[]
----


== Comparison with other meta-metamodels

Main difference: we aim for multiple implementations on different platforms, we want to serve both textual and projectional languages and editors.

[%autowidth]
|===
|LionCore |Ecore |MPS

|<<Language>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EPackage.html[EPackage]
|Language's structure aspect
(link:https://www.jetbrains.com/help/mps/structure.html[docs],
link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SLanguage.html[javadoc])

|<<Annotation>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/common/notify/Adapter.html[Adapter] (M1) / link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EAnnotation.html[EAnnotation] (M2)
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590288%28jetbrains.mps.lang.core.structure%29%2F3364660638048049748[NodeAttribute] (link:https://www.jetbrains.com/help/mps/structure.html#attributes[docs])

|<<Concept>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EClass.html[EClass]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F1071489090640[ConceptDeclaration]
(link:https://www.jetbrains.com/help/mps/structure.html#conceptsandconceptinterfaces[docs],
link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SConcept.html[javadoc])

|<<Interface>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EClass.html[EClass]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F1169125989551[InterfaceConceptDeclaration]
(link:https://www.jetbrains.com/help/mps/structure.html#conceptsandconceptinterfaces[docs],
link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SInterfaceConcept.html[javadoc])

|<<PrimitiveType>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EDataType.html[EDataType]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F1083243159079[PrimitiveDataTypeDeclaration]
(link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SPrimitiveDataType.html[javadoc])

|<<Enumeration>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EEnum.html[EEnum]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F3348158742936976479[EnumerationDeclaration]
(link:https://www.jetbrains.com/help/mps/structure.html#enumerationds[docs],
link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SEnumeration.html[javadoc])

|<<EnumerationLiteral>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EEnumLiteral.html[EEnumLiteral]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F3348158742936976480[EnumerationMemberLiteral]
(link:https://www.jetbrains.com/help/mps/structure.html#enumerationds[docs],
link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SEnumerationLiteral.html[javadoc])

|<<Containment>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EReference.html[EReference]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F1071489288298[LinkDeclaration]
(link:https://www.jetbrains.com/help/mps/structure.html#children[docs],
link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SContainmentLink.html[javadoc])

|<<Reference>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EReference.html[EReference]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F1071489288298[LinkDeclaration]
(link:https://www.jetbrains.com/help/mps/structure.html[docs],
link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SReferenceLink.html[javadoc])

|<<Property>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EAttribute.html[EAttribute]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F1071489288299[PropertyDeclaration]
(link:https://www.jetbrains.com/help/mps/structure.html#properties[docs],
link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SProperty.html[javadoc])

|<<IKeyed>>
|--
|--

|<<LanguageEntity>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EClassifier.html[EClassifier]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F1588368162880706270[IStructureElement]
(link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SElement.html[javadoc])

|<<Classifier>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EClass.html[EClass]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F1169125787135[AbstractConceptDeclaration]
(link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SAbstractConcept.html[javadoc])

|<<DataType>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EDataType.html[EDataType]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F1082978164218[DataTypeDeclaration]
(link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SDataType.html[javadoc])

|<<Feature>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EStructuralFeature.html[EStructuralFeature]
|
(link:https://www.jetbrains.com/help/mps/structure.html#conceptmembers[docs],
link:https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SConceptFeature.html[javadoc])

|<<Link>>
|link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/EReference.html[EReference]
|link:http://127.0.0.1:63320/node?ref=r%3A00000000-0000-4000-0000-011c89590292%28jetbrains.mps.lang.structure.structure%29%2F1071489288298[LinkDeclaration]
(https://alexanderpann.github.io/mps-openapi-doc/javadoc_2021.2/org/jetbrains/mps/openapi/language/SAbstractLink.html[javadoc])

|===


=== Comparison with Ecore

link:https://download.eclipse.org/modeling/emf/emf/javadoc/2.11/org/eclipse/emf/ecore/package-summary.html[javadoc]

image:images/EcoreRelations.png[]

=== Comparison with MPS

image:images/mps-structure-language.png[]
