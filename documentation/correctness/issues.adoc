= Issues

It makes sense to phrase the answer as a collection of _issues_, instead of giving a hard "`yes/no`" answer.
An **issue** is (to be defined as) a specific point in a serialization chunk where a specific kind of incorrectness arises.

Many (kinds of) issues allow a meaningful (full or partial) _recovery_ — i.e.: they can be recovered from.
Recovery is often obvious enough that it can be performed programmatically — i.e.: automatically.
E.g., an illegal trailing comma in a JSON array should be reported but can subsequently be safely ignored.

An unresolved reference can be left in as-is, and treated as an unknown (but not a _absent_) value.
It's then up to the consumer of a serialization chunk to give a special meaning — i.e., domain-specific semantics — to that particular value.
In some cases, that might not be possible or desirable to do, e.g.: most interpreters and code generators can only work with a completely correct, and complete model.
That means they might have to combine —or "`stitch together`"— multiple serialization chunks to produce a complete model.

It's entirely up to the consumer of the serialization chunk to validate its correctness, and to decide what to do with any resulting issues.
Especially issues that don't permit programmatic recovery, should be reported very clearly to the domain/subject matter expert, in a way that explains what they can do to repair/prevent is.
A serialization chunk must be editable/mutable (by a suitable client, after deserialization) even if it has issues.

A consumer of a serialization chunk could implement recovery for kinds of issues that permit programmatic recovery as procedures that modify the serialization chunk.


== Details to be reported in an issue

A reported issue should contain the following pieces of information:

* An identification of the _kind_ of issue.
* A _location_: where the issue occurred — see <<_location,below>>.
* A user-readable message explaining what the issue is, and how it should be remedied.
Ideally, this message is computed from other information in the issue.
* The _severity_ of the issue that is an indication of the recoverability of the issue — see <<_severities,below>>.


=== Location

An issue is useless if it doesn't tell exactly what its location is.
A number of basic ways of identifying a location exist:

[horizontal]

Text-based::
A specific location in a text could be given in any of the following forms:
+
* A pair of integers (line, column), with the text starting at (1, 1).
* A character index (considering the text as a character stream), starting at 1.
* A _range_ of text given as a (pair consisting of a) character location and an integer length.
+
The first two forms are _character locations_ which are interchangeable, although the first form is inherently more user-friendly.
A range provide more information to work with, except for when the length is 1 or so large a number to be meaningful — e.g., effectively meaning "`the rest of the text`".
+
For issues arising on the JSON level, these are the only available ways to identify a location.
Unfortunately, not all JSON parsers are able to report problems in this way.

JSON-based::
JsonPathfootnote:[https://goessner.net/articles/JsonPath/] is a method to point to specific elements in JSON text in a precise way that's independent of textual location.
This way is useful from the structural level onwards.

Node-based::
Beyond the hierarchical level, it becomes possible to address specific nodes by their ID.
In addition, one can point to a specific feature (by key) and to a specific value of a multi-valued feature by index.
All in all: (<node-ID>[, <feature-key>[, <value-index>]]).

Location-forms can be thought to "`cascade`": it's convenient to augment a node-based location with a JSON-based location, and likewise a JSON-based location with a text-based one.


=== Severities

They are:

[horizontal]

Fully recoverable::

Partially recoverable::

Fatal::

