= Model correctness

We can identify a number of levels of correctness of a model.
Each level builds on the previous one, so achieving a certain level of correctness implies having achieved all previous levels.
The levels are divided into two layers.

.Model correctness explained in a diagram
image::../resources/correctness-diagrams/levels.svg[]


== Correctness of the JSON serialization of a model

A JSON serialization of a model is considered to be deserializable (precisely) if it's correct with respect to all these levels.

[horizontal]
Low-level syntactic:: The serialization is parsable as JSON.
Note that “parsable” doesn't necessarily mean “syntax-correct”.
E.g., trailing commas are not syntax-correct, but don't necessarily prevent the JSON from being parsable, nor deserializable.

Structural syntactic:: The JSON conforms to (the relevant version of) https://github.com/LIonWeb-org/lioncore-typescript/blob/main/schemas/generic-serialization.schema.json[the general JSON Schema for the serialization format].
The relevant version should be read off from the value of the `serializationFormatVersion` property of the root object.
Note that JSON Schema isn't powerful enough to express more high-level, nor referential constraints on the model serialized as JSON.

Hierarchical:: The JSON doesn't violate the following constraints.
+
* No double containments, i.e. nodes are not the children of multiple other nodes, nor of themselves.
* The `parent` property of a serialized node matches the `id` of the containing node (whenever that node is present).
* No (incompatible) double serializations.
* Node IDs are unique (within the serialization).
+
Note that links don't have to resolve, so no additional constraints are imposed.

Meta-referential:: The metamodels specified in the serialization are known and _available_ in the sense that the client('s deserializer) knows how to deserialize models conforming to them.
That might include aspects like type definitions, and metamodel-specific APIs.

Meta-structural:: The seralization matches the metamodels - in particular:
+
* Concept IDs are (uniquely) resolvable.
* Every key in the `properties`, `children`, or `references` sub objects of the object corresponding to a serialized node is the ID of a feature of the concept pointed to by the `concept` ID value.
* No additional key-value pairs are present in those sub objects.
* A key in the `properties` sub object corresponds to ID of a `Property` feature, etc.
* For each key-value pair in the `properties` sub object: the value has a type matching the `type` specified by the `Property` feature corresponding to the key.
+
Because the model hasn't been deserialized at this point, incorrectness can't be reported yet as a model with references to nodes.
Instead, we need another means of referencing a specific location in the serialization, such as an XPath and/or a line/column identification.


== Correctness of the deserialized model

[horizontal]
Referential:: All references resolve.
Constraints:: No constraint violations.

Incorrectness can be reported as a model with references to nodes.
For multi-valued features, an index has to be included as well.

