= Model correctness

Whether a model is _correct_ –- or _valid_, or _consistent_ –- is an important question.
Correctness ultimately determines whether a model is useful in the context it exists in.
Answering that question only with a simple "`yes`" or "`no`" is too simplistic: a model can be incorrect in different ways and on different levels.

Not being able to resolve a reference is a different kind of failure than violating a semantic constraint.
Having an illegal extra comma in an array somewhere in the JSON serialization chunk of a model -- e.g. `[ 0, 1, 2**,** ]` -- should not prevent that serialization chunk from being deserializable.

[IMPORTANT]
====
We'll talk about _correctness_ from now, and consider _validity_ and _consistency_ to be equivalent concepts.
====

It makes sense to phrase the answer as a collection of _issues_, instead of giving a hard "`yes/no`" answer.
An issue is a specific point in the model where a specific kind of incorrectness arises.
Many (kinds of) issues can be meaningfully recovered from, and recovery can often be obvious to the point it can be automatic.
The unresolved reference can be left in as-is, and treated as an unknown (but not a _missing_) value with special meaning (i.e., domain-specific semantics).
The illegal comma should be reported but can subsequently be safely ignored.
In cases where recovery is not automatic, an issue should be very clear to the user what they can do to resolve it.
A model must be editable/mutable -- and even usable to some -- even if it has issues.

LionWeb provides a precise notion for model correctness in the form of a multi-leveled specification.
For each level, it specifies what kinds of incorrectness can arise, how these should be reported as issues, and whether and how these can be meaningfully _recovered_ from.
This approach provides a degree of resilience: issues arising in one level don't necessarily prohibit determining whether a model exhibits incorrectness on another level, provided an issue can be meaningfully _recovered_ from.

LionWeb provides a JSON serialization format for models: the serialization chunk.
LionWeb intentionally doesn't prescribe anything about the _programmatic representation_ of models -- i.e.: the runtime or in-memory representation that's the result of deserializing a serialization chunk of a model -- leaving implementors of language-oriented tooling free to choose the representation that's right for them.
Because of that, this specification is phrased _completely_ in terms of the JSON serialization.
The first three levels of this specification pertain purely to the JSON that's supposed to be the serialization chunk of a model, and are language(s)-agnostic -- essentially, this is about whether the JSON is _well-formed_ as a serialization chunk in JSON format.
The next levels _could_ be phrased in terms of a programmatic representation, but the equivalent formulation purely in terms of the serialization format works just as well.

This specification admits some flexibility on the first three, JSON-centric levels.
That is because the behavior and adaptability of JSON parsers differ from implementation to implementation.
We simply can't (and don't want to demand) that a LionWeb implementation always produces issues, even if they're recoverable or ignorable anyway.


== Overview of the levels

We first give an overview of the various levels, and what each pertains to, at first without specifying the corresponding kinds of issues that may arise in that level.
The list is roughly in order from low-level to language(s)-specific.

[horizontal]

Low-level syntactic::
Pertains to the text that's (supposed to be) the JSON serialization chunk of a model.

Structural syntactic::
Pertains to the syntactic structure of the parsed JSON text.
It's essentially equivalent to applying a generic JSON Schema.

Hierarchical::
Pertains to non-local, inter-node constraints on the parsed JSON text.
An example is that a node that declared a parent node must be contained as a child of that parent node.

Meta-structural::
This means that the serialization chunk conforms to the language(s) it declares to be an instance of.
An example is that a node must declare values for exactly the features of the classifier it declares.

Referential::
This pertains to whether references resolve within the chunk.
An unresolvable reference doesn't prevent being able to work with the model, but it often prohibits the next level –– Constraints -- from producing meaningful results.

Constraints::
This pertains to a language(s)-specific notion of correctness.
An incorrectness would typically either lead to a direct failure in the model's semantics -- i.e.: its execution through interpretation, or generating code and running that --, or to the result of the semantics not making sense in the (context of the) domain.
This distinction effectively divides this level in two sublevels, but it's up to the language(s) designers to expose those.
In our experience, a significant part of constraints is "`type-informed`" which means that _type computation/derivation_ is probably an intrinsic part of the constraints aspect of any language.

[NOTE]
====
LionWeb uses explicit, ID-based references, which means that scoping is not needed to resolve references.
Nevertheless, scoping probably still plays some role in any language.
Consider the following constraint in an ERD-style language: "`in a reference to a field of a referenced entity, the field referenced must be a field of the entity referenced`".
Even though this is a constraint, it can be interpreted as a scoping rule as well, and the language's UI should take it into account when providing content assist to the language's users.
====


== Overview of the severity

Each issue has a _severity_ that is an indication of the recoverability of the issue.
They are:

[horizontal]

Ignorable::

Fixable::

Stubbable::

Fatal::


== Low-level syntactic

== Structural syntactic

== Hierarchical

== Meta-structural

== Referential

== Constraints

